<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QApplicationContext: QApplicationContext</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QApplicationContext
   </div>
   <div id="projectbrief">A DI-Container for Qt-based applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QApplicationContext </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a>A DI-Container for Qt-based applications, inspired by Spring</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Motivation</h1>
<p>As an experienced developer, you know how crucial it is to follow the SOC (Separation Of Concern) - principle: <br  />
 Each component shall be responsible for "one task" only, (or, at least, for one set of related tasks). <br  />
 Things that are outside of a component's realm shall be delegated to other components. <br  />
 This, of course, means that some components will need to get references to those other components, commonly referred to as "Dependencies". <br  />
 Following this rule greatly increases testability of your components, thus making your software more robust.</p>
<p>But, sooner or later, you will ask yourself: How do I wire all those inter-dependent components together? <br  />
 How do I create application-wide "singletons" (without resorting to C++ singletions, which are notoriously brittle), and how can I create multiple implmentations of the same interface?</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Features</h1>
<ul>
<li>Provides an easy-to use Container for Dependency-Injection of Qt-based components.</li>
<li>Offers a typesafe syntax for declaring dependencies between components in C++.</li>
<li>Automatically determines the precise order in which the inter-dependent components must be instantiated.</li>
<li>Helps make the components <em>container-agnostic</em>.</li>
<li>Dependency-injection via constructor.</li>
<li>Dependency-injection via Qt-properties.</li>
<li>Supports both one-to-one and one-to-many relations between components.</li>
<li>Further configuration of components after creation, including externalized configuration (using <code>QSettings</code>).</li>
<li>Automatic invocation of an <em>init-method</em> after creation, using Qt-slots.</li>
<li>Offers a Qt-signal for "published" components, together with a type-safe <code>subscribe()</code> mechanism.</li>
<li>Fail-fast, i.e. terminate compilation with meaningful diagnostics if possible.</li>
<li>Helps to find runtime-problems by generating verbose logging (using a <code>QLoggingCategory</code>).</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
An example</h1>
<p>Suppose you have created a component named 'RestPropFetcher'. This component fetches a String-value from a Website, using http-GET and exposes this value as a Q_PROPERTY. Naturally, this component will make use of a <code>QNetworkAccessManager</code>. Also, a URL will be passed into the constructor. The declaration of such a component may look like this: </p><pre class="fragment">class RestPropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)


  public:

  RestPropFetcher(const QString&amp; url, QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  QString value() const;

  QString url() const;


  signals:
  void valueChanged();
};
</pre><p>Given the above component, the invocation of the constructor would look like this: </p><pre class="fragment">RestPropFetcher* fetcher = new RestPropFetcher{ QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, new QNetworkAccessManager}; 
</pre><p> When using a QApplicationContext, you can translate this constructor-call directly into an instantiation of <a class="el" href="structmcnepp_1_1qtdi_1_1_service.html" title="Describes a service by its interface and implementation. Compilation will fail if either Srv is not a...">mcnepp::qtdi::Service</a>.</p>
<p>We will soon see why this direct translation is usually not a good idea, but just for the record, this is what it looks like: </p><pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardApplicationContext; // 1

Service&lt;RestPropFetcher&gt; decl{QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, new QNetworkAccessManager}; // 2

context -&gt; registerService(decl, "hamburgWeather"); // 3

context -&gt; publish(); // 4
</pre><ol type="1">
<li>Creates a <code><a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext.">mcnepp::qtdi::StandardApplicationContext</a></code> on the heap. Note that we assign it to a pointer of the interface <code><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a></code>. This avoids accidental use of non-public API.</li>
<li>Creates a Declaration for the RestPropFetcher. The two arguments (the URL and the pointer to the <code>QNetworkAccessManager</code>) will be stored with the registration. They will be passed on to the constructor when the service is published.</li>
<li>Registers a RestPropFetcher with the context. The first argument is the name that this service shall have in the QApplicationContext.</li>
<li>The context is published. It will instantiate a RestPropFetcher and pass the two arguments to the constructor.</li>
</ol>
<p>The above code has an obvious flaw: The <code>QNetworkAccessManager</code> is created outside the QApplicationContext. It will not be managed by the Context. Should another service need a <code>QNetworkAccessManager</code>, you would have to create another instance.</p>
<p>We fix this by not providing the pointer to the <code>QNetworkAccessManager</code>, but instead using a kind of "placeholder" for it. This placeholder is the class-template <code><a class="el" href="structmcnepp_1_1qtdi_1_1_dependency.html" title="Specifies a dependency of a service. Can by used as a type-argument for QApplicationContext::register...">mcnepp::qtdi::Dependency</a></code>. We create Dependencies by using one of the functions <a class="el" href="qapplicationcontext_8h.html#aa230bb92d281b0431f927577348acba9" title="Injects a mandatory Dependency.">mcnepp::qtdi::inject()</a>, <a class="el" href="qapplicationcontext_8h.html#afe4b3cbeda7748a3b87a0309720cba6b" title="Injects an optional Dependency to another ServiceRegistration. This function will utilize the Registr...">mcnepp::qtdi::injectIfPresent()</a> or <a class="el" href="qapplicationcontext_8h.html#aa230bb92d281b0431f927577348acba9" title="Injects a mandatory Dependency.">mcnepp::qtdi::inject()</a>.</p>
<p>You can think of <code>inject</code> as a request to the QApplicationContext: <em>If a service of this type has been registered, please provide it here!</em>.</p>
<p>By leveraging <code>inject()</code>, our code becomes this:</p>
<pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardApplicationContext; // 1

context -&gt; registerService&lt;QNetworkAccessManager&gt;(); // 2
Service&lt;RestPropFetcher&gt; decl{QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, inject&lt;QNetworkAccessManager&gt;()}; // 3
context -&gt; registerService(decl, "hamburgWeather"); // 4

context -&gt; publish(); // 5
</pre><ol type="1">
<li>Creates a StandardApplicationContext on the heap.</li>
<li>Registers a QNetworkAccessManager with the context. We are supplying no explicit name here, so the component will get an auto-generated name! <b>Note:</b> This line uses the simplified overload of QApplicationContext::registerService() for Services with no dependencies.</li>
<li>Creates a Declaration for a RestPropFetcher. Again, we pass the first constructor-argument (the URL) directly. However, for the second argument, we use <code>inject&lt;QNetworkAccessManager&gt;()</code>.</li>
<li>Registers the descriptor with the context (as before).</li>
<li>The context is published. It will instantiate a QNetworkAccessManager first, then a RestPropFetcher, injecting the QNetworkAccessManager into its constructor.</li>
</ol>
<h1><a class="anchor" id="autotoc_md6"></a>
Externalized Configuration</h1>
<p>In the above example, we were configuring the Url with a String-literal in the code. This is less than optimal, as we usually want to be able to change such configuration-values without re-compiling the program. <br  />
 This is made possible with so-called <em>placeholders</em> in the configured values: <br  />
 When passed to the function <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>, a placeholder embedded in <code>${ }</code> will be resolved by the QApplicationContext using Qt's <code>QSettings</code> class. <br  />
 You simply register one or more instances of <code>QSettings</code> with the context, using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ac500bf06847e80745233dcb6bc3992da" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>. This is what it looks like if you out-source the "url" configuration-value into an external configuration-file: </p><pre class="fragment">context -&gt; registerObject(new QSettings{"application.ini", QSettings::IniFormat, context});

context -&gt; registerService(Service&lt;RestPropFetcher&gt;{resolve("${hamburgWeatherUrl}"), inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather"); 
context -&gt; registerService(Service&lt;RestPropFetcher&gt;{resolve("${berlinWeatherUrl}"), inject&lt;QNetworkAccessManager&gt;()}, "berlinWeather"); 
</pre><p>You could even improve on this by re-factoring the common part of the Url into its own configuration-value: </p><pre class="fragment">context -&gt; registerService(Service&lt;RestPropFetcher&gt;{resolve("${baseUrl}?stationIds=${hamburgStationId}"), inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather"); 
context -&gt; registerService(Service&lt;RestPropFetcher&gt;{resolve("${baseUrl}?stationIds=${berlinStationId}"), inject&lt;QNetworkAccessManager&gt;()}, "berlinWeather"); 
</pre> <h2><a class="anchor" id="autotoc_md7"></a>
Configuring values of non-String types</h2>
<p>With <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>, you can also process arguments of types other than <code>QString</code>. You just need to specify the template-argument explicitly, or pass a default-value to be used when the expression cannot be resolved.</p>
<p>Let's say there was an argument of type <code>int</code> that specified the connection-timeout in milliseconds. Then, the service-declaration would be: </p><pre class="fragment">Service&lt;RestPropFetcher&gt; decl{resolve("${baseUrl}?stationIds=${hamburgStationId}"), resolve&lt;int&gt;("${connectionTimeout}"), inject&lt;QNetworkAccessManager&gt;()};
</pre><p> You will notice the explicit type-argument used on <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>. Needless to say, the configured value for the key "connectionTimeout" must resolve to a valid integer-literal!</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Specifying default values</h2>
<p>Sometimes, you may want to provide a constructor-argument that can be externally configured, but you are unsure whether the configuration will always be present at runtime.</p>
<p>There are two ways of doing this:</p>
<ol type="1">
<li>You can supply a default-value to the function-template <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a> as its second argument: <code>resolve("${connectionTimeout}", 5000)</code>. This works only for constructor-arguments (see previous section).</li>
<li>You can put a default-value into the placeholder-expression, separated from the placeholder by a colon: <code>"${connectionTimeout:5000}"</code>. Such an embedded default-value takes precedence over one supplied to mqnepp::qtdi::resolve(). This works for both constructor-arguments and Q_PROPERTYs (see next section).</li>
</ol>
<h2><a class="anchor" id="autotoc_md9"></a>
Specifying an explicit Group</h2>
<p>If you structure your configuration in a hierarchical manner, you may find it useful to put your configuration-values into a <code>QSettings::group()</code>. Such a group can be specified for your resolvable values by means of the <a class="el" href="qapplicationcontext_8h.html#aa857c57a5dd1923deee08a54f7191ab5" title="Makes a service_config.">mcnepp::qtdi::make_config()</a> function. In the following example, the configuration-keys "baseUrl", "hamburgStationId" and "connectionTimeout" are assumed to reside in the group named "mcnepp": </p><pre class="fragment">Service&lt;RestPropFetcher&gt; decl{resolve("${baseUrl}?stationIds=${hamburgStationId}"), resolve&lt;int&gt;("${connectionTimeout}"), inject&lt;QNetworkAccessManager&gt;()};
appContext -&gt; registerService(decl, "hamburgWeather", make_config({}, "mcnepp"));
</pre><h1><a class="anchor" id="autotoc_md10"></a>
Configuring services with Q_PROPERTY</h1>
<p>We have seen how we can inject configuration-values into Service-constructors. Another way of configuring Services is to use Q_PROPERTY declarations. Suppose we modify the declaration of <code>RestPropFetcher</code> like this: </p><pre class="fragment">class RestPropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(QString url READ url WRITE setUrl NOTIFY urlChanged)

  Q_PROPERTY(int connectionTimeout READ connectionTimeout WRITE setConnectionTimeout NOTIFY connectionTimeoutChanged)


  public:

  explicit RestPropFetcher(QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  QString value() const;

  QString url() const;

  void setUrl(const QString&amp;);

  void setConnectionTimeout(int);

  int connectionTimeout() const;

  signals:

  void valueChanged();
  void urlChanged();
  void connectionTimeoutChanged();
};
</pre><p>Now, the "url" cannot be injected into the constructor. Rather, it must be set explicitly via the corresponding Q_PROPERTY. For this, the yet unused <code>service_config</code> argument comes into play: It contains a <code>QVariantMap</code> with the names and values of properties to set: </p><pre class="fragment">context -&gt; registerService(Service&lt;RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather", make_config({{"url", "${baseUrl}?stationIds=${hamburgStationId}"}, {"connectionTimeout", "${connectionTimeout:5000}}));
context -&gt; registerService(Service&lt;RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "berlinWeather", make_config({{"url", "${baseUrl}?stationIds=${berlinStationId}"}, {"connectionTimeout", "${connectionTimeout:5000}})); 
</pre><p> As you can see, the code has changed quite significantly: instead of supplying the Url as a constructor-argument, you use <a class="el" href="qapplicationcontext_8h.html#aa857c57a5dd1923deee08a54f7191ab5" title="Makes a service_config.">mcnepp::qtdi::make_config()</a> and pass in the key/value-pairs for configuring the service's url and connectionTimeouts as Q_PROPERTYs.</p>
<p><b>Note:</b> Every property supplied to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a020ed18a23366ea6122bc7346442e6db" title="Registers a service with this ApplicationContext.">mcnepp::qtdi::QApplicationContext::registerService()</a> will be considered a potential Q_PROPERTY of the target-service. <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> will fail if no such property can be found. <br  />
 However, if you prefix the property-key with a dot, it will be considered a <em>private property</em>. It will still be resolved via QSettings, but no attempt will be made to access a matching Q_PROPERTY. Such <em>private properties</em> may be passed to a <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(QAppli...">mcnepp::qtdi::QApplicationContextPostProcessor</a> (see section "Tweaking services" below).</p>
<h1><a class="anchor" id="autotoc_md11"></a>
Managed Services vs. Un-managed Objects</h1>
<p>The function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a020ed18a23366ea6122bc7346442e6db" title="Registers a service with this ApplicationContext.">mcnepp::qtdi::QApplicationContext::registerService()</a> that was shown in the preceeding example results in the creation of a <code>managed service</code>. <br  />
 The entire lifecylce of the registered Service will be managed by the QApplicationContext. <br  />
 Sometimes, however, it will be necessary to register an existing QObject with the ApplicationContext and make it available to other components as a dependency. <br  />
 A reason for this may be that the constructor of the class does not merely accept other <code>QObject</code>-pointers (as "dependencies"), but also <code>QString</code>s or other non-QObject-typed value. <br  />
 A good example would be registering objects of type <code>QSettings</code>, which play an important role in <em>Externalized Configuration</em> (see below). <br  />
</p>
<p>There are some crucial differences between <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a020ed18a23366ea6122bc7346442e6db" title="Registers a service with this ApplicationContext.">mcnepp::qtdi::QApplicationContext::registerService()</a> and <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ac500bf06847e80745233dcb6bc3992da" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>, as the following table shows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">registerService   </th><th class="markdownTableHeadNone">registerObject    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Instantiation of the object   </td><td class="markdownTableBodyNone">upon <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a>   </td><td class="markdownTableBodyNone">prior to the registration with the QApplicationContext    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">When does the Q_PROPERTY <code>Registration::publishedObjects</code> become non-empty?   </td><td class="markdownTableBodyNone">upon <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a>   </td><td class="markdownTableBodyNone">immediately after the registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Naming of the QObject   </td><td class="markdownTableBodyNone"><code>QObject::objectName</code> is set to the name of the registration   </td><td class="markdownTableBodyNone"><code>QObject::objectName</code> is not touched by QApplicationContext    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Handling of Properties   </td><td class="markdownTableBodyNone">The key/value-pairs supplied at registration will be set as Q_PROPERTYs by QApplicationContext   </td><td class="markdownTableBodyNone">All properties must be set before registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Processing by <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(QAppli...">mcnepp::qtdi::QApplicationContextPostProcessor</a>   </td><td class="markdownTableBodyNone">Every service will be processed by the registered QApplicationContextPostProcessors   </td><td class="markdownTableBodyNone">Object is not processed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Invocation of <em>init-method</em>   </td><td class="markdownTableBodyNone">If present, will be invoked by QApplicationContext   </td><td class="markdownTableBodyNone">If present, must have been invoked prior to registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Destruction of the object   </td><td class="markdownTableBodyNone">upon destruction of the QApplicationContext   </td><td class="markdownTableBodyNone">at the discrection of the code that created it   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md12"></a>
Types of dependency-relations</h1>
<p>In our previous example, we have seen the dependency of our <code>RestPropFetcher</code> to a <code>QNetworkAccessManager</code>. <br  />
 This constitutes a <em>mandatory dependency</em>: instantion of the <code>RestPropFetcher</code>will fail if no <code>QNetworkAccessManager</code>can be found. However, there are more ways to express a dependency-relation. <br  />
 This is reflected by the enum-type <code><a class="el" href="qapplicationcontext_8h.html#aa26d711edb47348796326730adbbc521" title="Specifies the kind of a service-dependency. Will be used as a non-type argument to Dependency,...">mcnepp::qtdi::Kind</a></code> and its enum-constants as listed below:</p>
<h2><a class="anchor" id="autotoc_md13"></a>
MANDATORY</h2>
<p>As stated before, mandatory dependencies enforce that there is exactly one service of the dependency-type present in the ApplicationContext. Otherwise, publication will fail. Mandatory dependencies can be specified by using inject(): </p><pre class="fragment">registerService(Service&lt;RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()});
</pre><h2><a class="anchor" id="autotoc_md14"></a>
OPTIONAL</h2>
<p>A service that has an <em>optional dependency</em> to another service may be instantiated even when no matching other service can be found in the ApplicationContext. In that case, <code>nullptr</code> will be passed to the service's constructor. <br  />
 Optional dependencies are specified the <code>Dependency</code> helper-template. Suppose it were possible to create our <code>RestPropFetcher</code> without a <code>QNetworkAccessManage</code>: </p><pre class="fragment">registerService(Service&lt;RestPropFetcher&gt;{injectIfPresent&lt;QNetworkAccessManager&gt;()});
</pre> <h2><a class="anchor" id="autotoc_md15"></a>
N (one-to-many)</h2>
<p>Now, let's extend our example a bit: we want to create a component that shall receive the fetched values from all RestPropFetchers and somehow sum them up. Such a component could look like this: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;RestPropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> Note that the above component comprises a one-to-,any relationship with its dependent components. We must notify the QApplicationContext about this, so that it can correctly inject all the matching dependencies into the component's constructor. <br  />
 The following statement will do the trick: </p><pre class="fragment">context -&gt; registerService(Service&lt;PropFetcherAggregator&gt;{injectAll&lt;RestPropFetcher&gt;()}, "propFetcherAggregation");
</pre><p> <b>Note:</b>, while constructing the <code>QList</code> with dependencies, the ordering of registrations of <b>non-interdependent services</b> will be honoured as much as possible. In the above example, the services "hamburgWeather" and "berlinWeather" will appear in that order in the <code>QList</code> that is passed to the <code>PropFetcherAggreator</code>.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
PRIVATE_COPY</h2>
<p>Sometime, you may want to ensure that every instance of your service will get its own instance of a dependency. This might be necessary if the dependency shall be configured (i.e. modified) by the dependent service, thus potentially affecting other dependent services. <br  />
 QApplicationContext defines the dependency-type PRIVATE_COPY for this. Applied to our example, you would enfore a private <code>QNetworkAccessManager</code> for both <code>RestPropFetcher</code>s like this: </p><pre class="fragment">context -&gt; registerService(Service&lt;RestPropFetcher&gt;{injectPrivateCopy&lt;QNetworkAccessManager&gt;()}, "berlinWeather"); 
context -&gt; registerService(Service&lt;RestPropFetcher&gt;{injectPrivateCopy&lt;QNetworkAccessManager&lt;()}, "hamburgWeather"); 
</pre><p> <b>Note:</b> The life-cycle of instances created with PRIVATE_COPY will not be managed by the ApplicationContext! Rather, the ApplicationContext will set the dependent object's <code>QObject::parent()</code> to the dependent service, thus it will be destructed when its parent is destructed.</p>
<p>The following table sums up the characteristics of the different types of dependencies:</p>
<table class="doxtable">
<tr>
<th>&#160;</th><th>Normal behaviour</th><th>What if no dependency can be found?</th><th>What if more than one dependency can be found? </th></tr>
<tr>
<td>MANDATORY</td><td>Injects one dependency into the dependent service.</td><td>If the dependency-type has an accessible default-constructor, this will be used to register and create an instance of that type. <br  />
If no default-constructor exists, publication of the ApplicationContext will fail. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
<tr>
<td>OPTIONAL</td><td>Injects one dependency into the dependent service</td><td>Injects <code>nullptr</code> into the dependent service. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
<tr>
<td>N</td><td>Injects all dependencies of the dependency-type that have been registered into the dependent service, using a <code>QList</code> </td><td>Injects an empty <code>QList</code> into the dependent service. </td><td>See 'Normal behaviour' </td></tr>
<tr>
<td>PRIVATE_COPY</td><td>Injects a newly created instance of the dependency-type and sets its <code>QObject::parent()</code> to the dependent service. </td><td>If the dependency-type has an accessible default-constructor, this will be used to create an instance of that type.<br  />
 If no default-constructor exists, publication of the ApplicationContext will fail. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md17"></a>
Service-interfaces</h1>
<p>In the preceeding example, we have used our QObject-derived class <code>RestPropFetcher</code> directly. We have also specified the class as the dependency-type for <code>PropFetcherAggregator</code>. <br  />
 However, in most complex applications you will likely use an abstract base-class (or 'interface'). Additionally, this interface need not be derived from QObject! <br  />
 This is well supported by QApplicationContext. First, let's declare our interface: </p><pre class="fragment">class PropFetcher  {

  public:

  virtual QString value() const = 0;

  virtual ~PropFetcher() = default;
};
</pre><p> Then, we modify our class <code>RestPropFetcher</code> so that it derives from both QObject and this interface: </p><pre class="fragment">class RestPropFetcher : public QObject, public PropFetcher {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(QString url READ url WRITE setURl NOTIFY urlChanged)

  public:

  explicit RestPropFetcher(QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  virtual QString value() const override;

  QString url() const;

  void setUrl(const QString&amp;);

  signals:

  void valueChanged();

  void urlChanged();
};
</pre><p> And lastly, we modify our class <code>PropFetcherAggregator</code> so that it accepts dependencies of the interface-type: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> Putting it all together, we use the helper-template <code>Service</code> for specifying both an interface-type and an implementation-type:</p>
<pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardQApplicationContext; 

context -&gt; registerService(Service&lt;PropFetcherAggregator&gt;{injectAllOf&lt;PropFetcher&gt;()}, "propFetcherAggration");

context -&gt; registerService(Service&lt;PropFetcher,RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather", make_config({{"url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}})); 
context -&gt; registerService(Service&lt;PropFetcher,RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "berlinWeather", make_config({{"url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10382"}}));

context -&gt; publish(); 
</pre><p> Two noteworthy things:</p>
<ol type="1">
<li>You may have noticed that the registration of the <code>QNetworkAccessManager</code> is no longer there. <br  />
 The reason for this is that the class has an accessible default-constructor. <code>QApplicationContext</code> makes sure that whenever a dependency for a specific type is resolved and a matching service has not been explicitly registered, a default-instance will be created if possible.</li>
<li>The order of registrations has been switched: now, the dependent service <code>PropFetcherAggregator</code> is registered before the services it depends on. This was done to demonstrate that, <b>regardless of the ordering of registrations</b>, the dependencies will be resolved correctly! <br  />
 <code>QApplicationContext</code> figures out automatically what the correct order must be.</li>
</ol>
<h1><a class="anchor" id="autotoc_md18"></a>
The Service-lifefycle</h1>
<p>Every service that is registered with a QApplicationContext will go through the following states, in the order shown. The names of these states are shown for illustration-purposes only. They are not visible outside the QApplicationContext. <br  />
 However, some transitions may have observable side-effects.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">External Trigger   </th><th class="markdownTableHeadNone">Internal Step   </th><th class="markdownTableHeadNone">State   </th><th class="markdownTableHeadNone">Observable side-effect    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" colspan="2">ApplicationContext::registerService()   </td><td class="markdownTableBodyNone">REGISTERED   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ApplicationContext::publish(bool)   </td><td class="markdownTableBodyNone">Instantiation via constructor or service_factory   </td><td class="markdownTableBodyNone">NEW   </td><td class="markdownTableBodyNone">Invocation of Services's constructor    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Set properties   </td><td class="markdownTableBodyNone">AFTER_PROPERTIES_SET   </td><td class="markdownTableBodyNone">Invocation of property-setters    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">Apply QApplicationContextPostProcessor   </td><td class="markdownTableBodyNone">PROCESSED   </td><td class="markdownTableBodyNone">Invocation of user-supplied QApplicationContextPostProcessor::process()    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">if exists, invoke init-method   </td><td class="markdownTableBodyNone">PUBLISHED   </td><td class="markdownTableBodyNone">emit signal Registration::publishedObjectsChanged    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">~ApplicationContext()   </td><td class="markdownTableBodyNone">delete service   </td><td class="markdownTableBodyNone">DESTROYED   </td><td class="markdownTableBodyNone">Invoke Services's destructor   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md19"></a>
Referencing other members of the ApplicationContext</h1>
<p>Sometimes, it may be necessary to inject one member of the ApplicationContext into another member not via constructor, but via a Q_PROPERTY. <br  />
 Suppose that each <code>PropFetcher</code> shall have (for whatever reason) a reference to the <code>PropFetcherAggregator</code>. <br  />
 This cannot be done via constructor-arguments, as it would constitute a dependency-circle! <br  />
 However, we could introduce a Q_PROPERTY like this: </p><pre class="fragment">class PropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(PropFetcherAggregator* summary READ summary WRITE setSummary NOTIFY summaryChanged)

  public:

  explicit PropFetcher(QObject* parent = nullptr);

  virtual QString value() const = 0;

  virtual PropFetcherAggregator* summary() const = 0;

  virtual void setSummary(PropFetcherAggregator*) = 0;

  signals:
  void valueChanged();

  void summaryChanged();
};
</pre><p> And here's how this property will be automatically set to the ApplicationContext's <code>PropFetcherAggregator</code>. Note the ampersand as the first character of the property-value, which makes this a <em>reference to another member</em>:</p>
<pre class="fragment">context -&gt; registerService(Service&lt;PropFetcherAggregator&gt;{injectAll&lt;PropFetcher&gt;()}, "propFetcherAggregator");

context -&gt; registerService(Service&lt;PropFetcher,RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather", make_config({
  {"url", "${weatherUrl}${hamburgStationId}"},
  {"summary", "&amp;propFetcherAggregator"}
}));
</pre> <h2><a class="anchor" id="autotoc_md20"></a>
Binding target-properties to source-properties of other members of the ApplicationContext</h2>
<p>In the preceeding example, we used a reference to another member to initialize of a Q_PROPERTY with a type of <code>QType*</code>, where <code>QType</code> is a class derived from <code>QObject</code>.</p>
<p>Since the value of such a property is another service in the ApplicationContext, the value can never change.</p>
<p>However, we might also want to <b>bind</b> a target-service's property to the corresponding source-property of another service. This can be achieved by using a property-value with the format <code>"&amp;ref.prop"</code>. The following example shows this: </p><pre class="fragment">QTimer timer1;

context -&gt; registerObject(&amp;timer1, "timer1"); // 1

context -&gt; registerService(Service&lt;QTimer&gt;{}, "timer2", make_config({{"interval", "&amp;timer1.interval"}})); // 2

timer1.setInterval(4711); // 3
</pre><ol type="1">
<li>We register a <code>QTimer</code> as "timer1".</li>
<li>We register a second <code>QTimer</code> as "timer2". We bind the property <code>interval</code> to the first timer's propery.</li>
<li>We change the first timer's interval. This will also change the second timer's interval!</li>
</ol>
<h1><a class="anchor" id="autotoc_md21"></a>
Accessing a service after registration</h1>
<p>So far, we have published the ApplicationContext and let it take care of wiring all the components together. <br  />
 In some cases, you need to obtain a reference to a member of the Context after it has been published. <br  />
 This is where the return-value of <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a020ed18a23366ea6122bc7346442e6db" title="Registers a service with this ApplicationContext.">mcnepp::qtdi::QApplicationContext::registerService()</a> comes into play: <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a Registration. Instances of this class are being returned by the public func...">mcnepp::qtdi::ServiceRegistration</a>.</p>
<p>It offers the method <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html#a1ae0d128c3d68f9d65ca536434508b9d" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a>, which is a type-safe version of a Qt-Signal. (It is actually implemented in terms of the Signal <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#aed815fb95cffed549b3fe7a2c9eebbfe" title="Signals when a service has been published.">mcnepp::qtdi::Registration::publishedObjectsChanged()</a>).</p>
<p>In addition to being type-safe, the method <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html#a1ae0d128c3d68f9d65ca536434508b9d" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a> has the advantage that it will automatically inject the service if you subscribe after the service has already been published. <br  />
 This code shows how to do this: </p><pre class="fragment">auto registration = context -&gt; registerService(Service&lt;PropFetcher,RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather", make_config({{"url", "${weatherUrl}${hamburgStationId}"}})); 

registration.subscribe(this, [](PropFetcher* fetcher) { qInfo() &lt;&lt; "I got the PropFetcher!"; });
</pre> <h1><a class="anchor" id="autotoc_md22"></a>
Accessing published members of the ApplicationContext</h1>
<p>In the previous paragraph, we used the <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a Registration. Instances of this class are being returned by the public func...">mcnepp::qtdi::ServiceRegistration</a> obtained by <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a020ed18a23366ea6122bc7346442e6db" title="Registers a service with this ApplicationContext.">mcnepp::qtdi::QApplicationContext::registerService()</a>, which refers to a single member of the ApplicationContext. However, we might be interested in all members of a certain service-type. <br  />
 This can be achieved using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a961953e2d50213098e05446b5450427b" title="Obtains a ServiceRegistration for a service-type and name.">mcnepp::qtdi::QApplicationContext::getRegistration()</a>, which yields a <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a Registration. Instances of this class are being returned by the public func...">mcnepp::qtdi::ServiceRegistration</a> that represents <em>all services of the requested service-type</em>.</p>
<pre class="fragment">auto registration = context -&gt; getRegistration&lt;PropFetcher&gt;();
qInfo() &lt;&lt; "There have been" &lt;&lt; registration.maxPublications() &lt;&lt; "RestPropFetchers so far!";    
</pre><p> You may also access a specific service by name: </p><pre class="fragment">auto registration = context -&gt; getRegistration&lt;PropFetcher&gt;("hamburgWeather");
if(!registration) {
 qWarning() &lt;&lt; "Could not obtain service 'hamburgWeather'";
}
</pre> <h1><a class="anchor" id="autotoc_md23"></a>
Tweaking services (QApplicationContextPostProcessor)</h1>
<p>Whenever a service has been instantiated and all properties have been set, QApplicationContext will apply all registered <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(QAppli...">mcnepp::qtdi::QApplicationContextPostProcessor</a>`s to it. These are user-supplied QObjects that implement the aforementioned interface which comprises a single method: </p><pre class="fragment">QApplicationContextPostProcessor::process(QApplicationContext*, QObject*,const QVariantMap&amp;)
</pre><p> In this method, you might apply further configuration to your service there, or perform logging or monitoring tasks.<br  />
 Any information that you might want to pass to a QApplicationContextPostProcessor can be supplied as so-called <em>private properties</em> via <a class="el" href="qapplicationcontext_8h.html#aa857c57a5dd1923deee08a54f7191ab5" title="Makes a service_config.">mcnepp::qtdi::make_config()</a>. Just prefix the property-key with a dot.</p>
<h1><a class="anchor" id="autotoc_md24"></a>
'Starting' services</h1>
<p>The last step done in <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> for each service is the invocation of an <em>init-method</em>, should one have been registered.</p>
<p><em>Init-methods</em> are supplied as part of the <code>service_config</code>, for example like this: </p><pre class="fragment">context -&gt; registerService(Service&lt;PropFetcherAggregator&gt;{injectAll&lt;PropFetcher&gt;()}, "propFetcherAggregator", make_config({}, "", false, "init"));
</pre><p> Suitable <em>init-methods</em> are must be <code>Q_INVOKABLE</code> methods with either no arguments, or with one argument of type <code>QApplicationContext*</code>.</p>
<h1><a class="anchor" id="autotoc_md25"></a>
Resolving ambiguities</h1>
<p>Sometimes, multiple instances of a service with the same service-type have been registered. <br  />
 (In our previous examples, this was the case with two instances of the <code>PropFetcher</code> service-type.) <br  />
 If you want to inject only one of those into a dependent service, how can you do that? <br  />
 Well, using the name of the registered service seems like a good idea. The following code will still provide a <code>QList&lt;PropFetcher*&gt;</code> to the <code>PropFetcherAggregator</code>. However, the List will contain solely the service that was registered under the name "hamburgWeather": <br  />
 </p><pre class="fragment">context -&gt; registerService(Service&lt;PropFetcherAggregator&gt;{injectAll&lt;PropFetcher&gt;("hamburgWeather")}, "propFetcherAggregator");
</pre> <h1><a class="anchor" id="autotoc_md26"></a>
Customizing service-instantiation</h1>
<p>So far, we have seen that each call to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a020ed18a23366ea6122bc7346442e6db" title="Registers a service with this ApplicationContext.">mcnepp::qtdi::QApplicationContext::registerService()</a> mirrors a corresponding constructor-invocation of the service-type.</p>
<p>In order for this to work, several pre-conditions must be true:</p>
<ol type="1">
<li>the constructor of the service must be accessible, i.e. declared <code>public</code>.</li>
<li>The number of mandatory arguments must match the arguments provided via <code>QApplicationContext::registerService()</code>, in excess of the service-name and, optionally, the <code>service_config</code>.</li>
<li>For each <code>Dependency&lt;T&gt;</code> with <code>Kind::MANDATORY</code>, <code>Kind::OPTIONAL</code> or <code>Kind::PRIVATE_COPY</code>, the argument-type must be <code>T*</code>.</li>
<li>For each <code>Dependency&lt;T&gt;</code> with <code>Kind::N</code>, the argument-type must be <code>QList&lt;T*&gt;</code>.</li>
</ol>
<p>If any of these conditions fails, then the invocation of <code>QApplicationContext::registerService()</code> will fail compilation.</p>
<p>However, there is a remedy: by specializing the template <a class="el" href="structmcnepp_1_1qtdi_1_1service__factory.html" title="A template that can be specialized to override the standard way of instantiating services....">mcnepp::qtdi::service_factory</a> for your service-type, you can provide your own "factory-function" that can overcome any of the above obstacles.</p>
<p>As with all such specializations, it must reside in the namespace of the primary template, i.e. <code>mcnepp::qtdi</code>.</p>
<p>The specialization must provide a call-operator that takes the arguments provided by QApplicationContext, adapts those arguments to the arguments expected by the service-type, and returns a pointer to the newly created service.</p>
<p>Suppose that the declaration of the class <code>PropFetcherAggregator</code> has been changed in the following way: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  static PropFetcherAggregator* create(const std::vector&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);

  private:

  explicit PropFetcherAggregator(const std::vector&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> Two things have been changed:</p>
<ol type="1">
<li>Instead of the constructor, which is now private, there is a public static factory-function "create".</li>
<li>The list of PropFetchers is supplied as a <code>std::vector</code>, not as a <code>QList</code>.</li>
</ol>
<p>Here is all that we have to do: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_factory&lt;PropFetcherAggregator&gt; {
    PropFetcherAggregator* operator()(const QList&lt;PropFetcher*&gt; fetchers) const {
      return PropFetcherAggregator::create(std::vector&lt;PropFetcher*&gt;{fetchers.begin(), fetchers.end()});
    }
  };
}
</pre><p> And, voila: We can register our service exactly as we did before!</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Publishing an ApplicationContext more than once</h1>
<p>Sometimes, it may be desirable to inovoke QApplicationContext::publish(bool) more than once. Proceeding with the previous example, there may be several independent modules that each want to supply a service of type <code>PropFetcher</code>. Each of these modules will rightly assume that the dependency of type <code>QNetworkAccessManager</code> will be automatically supplied by the QApplicationContext.</p>
<p>But which module shall then invoke QApplicationContext::publish(bool)? Do we need to coordinate this with additional code? That could be a bit unwieldly. Luckily, this is not necessary.</p>
<p>Given that each module has access to the (global) QApplicationContext, you can simply do this in some initialization-code in module A: </p><pre class="fragment">context -&gt; registerService(Service&lt;PropFetcher,RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "hamburgWeather", make_config({{"url", "${weatherUrl}${hamburgStationId}"}})); 
context -&gt; publish();
</pre><p> ...and this in module B: </p><pre class="fragment">context -&gt; registerService(Service&lt;PropFetcher,RestPropFetcher&gt;{inject&lt;QNetworkAccessManager&gt;()}, "berlinWeather", make_config({{"url", "${weatherUrl}${berlinStationId}"}})); 
context -&gt; publish();
</pre><p> At the first <code>publish()</code>, an instance of <code>QNetworkAccessManager</code> will be instantiated. It will be injected into both <code>RestPropFetchers</code>.</p>
<p>This will work <b>regardless of the order in which the modules are initialized</b>!</p>
<p>Now let's get back to our class <code>PropFetcherAggregator</code> from above. We'll assume that a third module C contains this initialization-code: </p><pre class="fragment">context -&gt; registerService(Service&lt;PropFetcherAggregator&gt;{injectAll&lt;PropFetcher&gt;()}, "propFetcherAggregator");
context -&gt; publish();
</pre><p> Unfortunately, this code will only have the desired effect of injecting all <code>PropFetchers</code> into the <code>PropFetcherAggregator</code> if it is executed after the code in modules A and B. Thus, we have once again introduced a mandatory order of initialization!</p>
<p>But we can do better: First, we need to tweak our class <code>PropFetcherAggregator</code> a little: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;PropFetcher*&gt;&amp; fetchers = {}, QObject* parent = nullptr);

  void addPropFetcher(PropFetcher*);
};
</pre><p> As you can see, we've added a default-value for the constructor-argument, thus made the class default-constructible. We've also added a member-function <code>addPropFetcher(PropFetcher*)</code>, which we'll put to use in the revised initialization-code in module C: </p><pre class="fragment">auto aggregatorRegistration = context -&gt; registerService&lt;PropFetcherAggregator&gt;("propFetcherAggregator"); // 1

aggregatorRegistration-&gt;autowire(&amp;PropFetcherAggregator::addPropFetcher); // 2

context -&gt; publish();
</pre><ol type="1">
<li>No need to specify Dependency anymore. Therefore, we can use the simplified overload of QApplicationContext::registerService().</li>
<li>Will cause all PropFetchers to be injected into PropFetcherAggregator.</li>
</ol>
<p>And that's all that is needed to get rid of any mandatory order of initialization of the modules A, B and C.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Publish-mode ('allowPartial')</h1>
<p>The function QApplicationContext::publish(bool) has a boolean argument <code>allowPartial</code> with a default-value of <code>false</code>. The following table shows how this argument affects the outcome of the function:</p>
<h2><a class="anchor" id="autotoc_md29"></a>
allowPartial = false:</h2>
<ul>
<li>If publication of one service fails for whatever reason, the function will immediately return without attempts to publish other services.</li>
<li>All errors that occur while publishing a service will be logged with the level QtMsgType::QtCriticalMessage.</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
allowPartial = true:</h2>
<ul>
<li>If publication of one service fails for reasons that may be fixed, the function will continue to publish other services. Such reasons include:<ul>
<li>unresolved dependencies (as those may be registered later).</li>
<li>unresolved config-values (as those may be configured later).</li>
</ul>
</li>
<li>Such "fixable errors" that occur while publishing a service will be logged with the level QtMsgType::QtWarningMessage.</li>
<li>If publication of one service fails for reasons that will prevail, the function will will immediately return without attempts to publish other services. Such reasons include:<ul>
<li>ambiguous dependencies (as those cannot not be removed from the ApplicationContext).</li>
<li>non-existing names of Q_PROPERTYs.</li>
<li>syntactically erronous config-keys (such as <code>"$interval}"</code>).</li>
</ul>
</li>
<li>Such "fatal errors" that occur while publishing a service will be logged with the level QtMsgType::QtCriticalMessage. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
