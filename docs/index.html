<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QApplicationContext: QApplicationContext</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QApplicationContext
   </div>
   <div id="projectbrief">A DI-Container for Qt-based applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QApplicationContext </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a></p>
<p>A DI-Container for Qt-based applications, inspired by Spring</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Motivation</h1>
<p>As an experienced developer, you know how crucial it is to follow the SOC (Separation Of Concern) - principle: <br  />
 Each component shall be responsible for "one task" only, (or, at least, for one set of related tasks). <br  />
 Things that are outside of a component's realm shall be delegated to other components. <br  />
 This, of course, means that some components will need to get references to those other components, commonly referred to as "Dependencies". <br  />
 Following this rule greatly increases testability of your components, thus making your software more robust.</p>
<p>But, sooner or later, you will ask yourself: How do I wire all those inter-dependent components together? <br  />
 How do I create application-wide "singletons" (without resorting to C++ singletions, which are notoriously brittle), and how can I create multiple implementations of the same interface?</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Features</h1>
<ul>
<li>Provides an easy-to use Container for Dependency-Injection of Qt-based components.</li>
<li>Offers a typesafe syntax for declaring dependencies between components in C++.</li>
<li>Automatically determines the precise order in which the inter-dependent components must be instantiated.</li>
<li>Helps make the components <em>container-agnostic</em>.</li>
<li>Dependency-injection via constructor.</li>
<li>Dependency-injection via Qt-properties.</li>
<li>Supports both one-to-one and one-to-many relations between components.</li>
<li>Further configuration of components after creation, including externalized configuration (using <code>QSettings</code>).</li>
<li>Automatic invocation of an <em>init-method</em> after creation, using Qt-slots.</li>
<li>Offers a Qt-signal for "published" components, together with a type-safe <code>subscribe()</code> mechanism.</li>
<li>Fail-fast, i.e. terminate compilation with meaningful diagnostics if possible.</li>
<li>Helps to find runtime-problems by generating verbose logging (using a <code>QLoggingCategory</code>).</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
An example</h1>
<p>Suppose you have created a component named 'RestPropFetcher'. This component fetches a String-value from a Website, using http-GET and exposes this value as a Q_PROPERTY. Naturally, this component will make use of a <code>QNetworkAccessManager</code>. Also, a URL will be passed into the constructor. The declaration of such a component may look like this: </p><pre class="fragment">class RestPropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)


  public:

  RestPropFetcher(const QString&amp; url, QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  QString value() const;

  QString url() const;


  signals:
  void valueChanged();
};
</pre><p>Given the above component, the invocation of the constructor would look like this: </p><pre class="fragment">RestPropFetcher* fetcher = new RestPropFetcher{ QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, new QNetworkAccessManager}; 
</pre><p>When using a QApplicationContext, you can translate this constructor-call directly into an instantiation of <a class="el" href="structmcnepp_1_1qtdi_1_1_service.html" title="Describes a service by its interface and implementation. Compilation will fail if either Srv is not a...">mcnepp::qtdi::Service</a>.</p>
<p>We will soon see why this direct translation is usually not a good idea, but just for the record, this is what it looks like: </p><pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardApplicationContext; // 1

auto decl = service&lt;RestPropFetcher&gt;(QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, new QNetworkAccessManager}; // 2

context -&gt; registerService(decl, "hamburgWeather"); // 3

context -&gt; publish(); // 4
</pre><ol type="1">
<li>Creates a <code><a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext. Using this class is the &quot;canonical way&quot; of ...">mcnepp::qtdi::StandardApplicationContext</a></code> on the heap. Note that we assign it to a pointer of the interface <code><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a></code>. This avoids accidental use of non-public API.</li>
<li>Creates a Declaration for the RestPropFetcher. The two arguments (the URL and the pointer to the <code>QNetworkAccessManager</code>) will be stored with the registration. They will be passed on to the constructor when the service is published.</li>
<li>Registers a RestPropFetcher with the context. The first argument is the name that this service shall have in the QApplicationContext.</li>
<li>The context is published. It will instantiate a RestPropFetcher and pass the two arguments to the constructor.</li>
</ol>
<p>The above code has an obvious flaw: The <code>QNetworkAccessManager</code> is created outside the QApplicationContext. It will not be managed by the Context. Should another service need a <code>QNetworkAccessManager</code>, you would have to create another instance.</p>
<p>We fix this by not providing the pointer to the <code>QNetworkAccessManager</code>, but instead using a kind of "proxy" for it. This proxy is of the opaque type <code><a class="el" href="qapplicationcontext_8h.html#a5b04fa60e417c01aff57377715036970">mcnepp::qtdi::Dependency</a></code>. We can create Dependencies by using one of the functions <a class="el" href="qapplicationcontext_8h.html#a7f1f15461634592926ae1efd11f50ea6" title="Injects a mandatory Dependency.  This will instruct the ApplicationContext to find exactly one Depend...">mcnepp::qtdi::inject()</a>, <a class="el" href="qapplicationcontext_8h.html#a62777d7ae6b38c128de21de31f22ac5a" title="Injects an optional Dependency.  This will instruct the ApplicationContext to find exactly one Depend...">mcnepp::qtdi::injectIfPresent()</a> or <a class="el" href="qapplicationcontext_8h.html#a7f1f15461634592926ae1efd11f50ea6" title="Injects a mandatory Dependency.  This will instruct the ApplicationContext to find exactly one Depend...">mcnepp::qtdi::inject()</a>.</p>
<p>You can think of <code>inject</code> as a request to the QApplicationContext: <em>If a service of this type has been registered, please provide it here!</em>.</p>
<p>By leveraging <code>inject()</code>, our code becomes this:</p>
<pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardApplicationContext; // 1

context -&gt; registerService&lt;QNetworkAccessManager&gt;(); // 2
auto decl = service&lt;RestPropFetcher&gt;(QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, inject&lt;QNetworkAccessManager&gt;()); // 3
context -&gt; registerService(decl, "hamburgWeather"); // 4

context -&gt; publish(); // 5
</pre><ol type="1">
<li>Creates a StandardApplicationContext on the heap.</li>
<li>Registers a QNetworkAccessManager with the context. We are supplying no explicit name here, so the component will get an auto-generated name! <b>Note:</b> This line uses the simplified overload of QApplicationContext::registerService() for Services with no dependencies.</li>
<li>Creates a Declaration for a RestPropFetcher. Again, we pass the first constructor-argument (the URL) directly. However, for the second argument, we use <code>inject&lt;QNetworkAccessManager&gt;()</code>.</li>
<li>Registers the descriptor with the context (as before).</li>
<li>The context is published. It will instantiate a QNetworkAccessManager first, then a RestPropFetcher, injecting the QNetworkAccessManager into its constructor.</li>
</ol>
<p><b>Note:</b> In the above example, we obtain the <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> for the <code>QNetworkAccessManager</code> in line 2.<br  />
 Whenever we want to express a dependency for a Service and we have the corresponding ServiceRegistration at hand, we can leave out the <code>inject()</code> and pass the ServiceRegistration directly as a dependency. <br  />
Thus, the lines 2 to 4 from our example could be simplified like this: </p><pre class="fragment">auto networkRegistration = context -&gt; registerService&lt;QNetworkAccessManager&gt;(); // 2
context -&gt; registerService(service&lt;RestPropFetcher&gt;(QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"), networkRegistration}, "hamburgWeather"); // 3
</pre><h1><a class="anchor" id="autotoc_md11"></a>
Parent-Child relation</h1>
<p>In the preceding example, the class <code>RestPropFetcher</code> was introduced which had the following constructor: </p><pre class="fragment">RestPropFetcher(const QString&amp; url, QNetworkAccessManager* networkManager, QObject* parent = nullptr);
</pre><p>This is typical for QObject-based services: the first arguments (aka the dependencies) are mandatory, while the last argument is an optional <code>parent</code>. <br  />
In the preceding example, the service was registered by supplying the first two arguments explicitly. Thus, no <code>parent</code> was supplied. <br  />
QApplicationContext will check for every service after creation whether the service already has a QObject::parent(). If not, <b>it will set itself as the service's parent</b> using QObject::setParent(QObject*). <br  />
However, what would you do if you had a constructor with a <em>mandatory parent</em>? <br  />
In that case, <a class="el" href="qapplicationcontext_8h.html#a2b4cd088db70b5b3179022c6e0b00fe2" title="Creates a placeholder for injecting the ApplicationContext into a service as the parent....">mcnepp::qtdi::injectParent()</a> comes to the rescue: </p><pre class="fragment">context-&gt;registerService(service&lt;RestPropFetcher&gt;(QString{"https://whatever"}, inject&lt;QNetworkAccessManager&gt;(), injectParent()));
</pre><p>This will cause the ApplicationContext to inject itself into the constructor as the parent.</p>
<h1><a class="anchor" id="externalized-configuration"></a>
Externalized Configuration</h1>
<p>In the above example, we were configuring the Url with a String-literal in the code. This is less than optimal, as we usually want to be able to change such configuration-values without re-compiling the program. <br  />
 This is made possible with so-called <em>placeholders</em> in the configured values: <br  />
 When passed to the function <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>, a placeholder embedded in <code>${ }</code> will be resolved by the QApplicationContext using Qt's <code>QSettings</code> class. <br  />
 You simply register one or more instances of <code>QSettings</code> with the context, using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5ddf9204ec6f0071793adb3c770bc3ab" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>.</p>
<h2><a class="anchor" id="constructor-arguments"></a>
Using Constructor-arguments</h2>
<p>This is what it looks like if you out-source the "url" configuration-value into an external configuration-file: </p><pre class="fragment">context -&gt; registerObject(new QSettings{"application.ini", QSettings::IniFormat, context});

context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${hamburgWeatherUrl}"), inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather"); 
context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${berlinWeatherUrl}"), inject&lt;QNetworkAccessManager&gt;()), "berlinWeather"); 
</pre><p>You could even improve on this by re-factoring the common part of the Url into its own configuration-value: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${hamburgStationId}"), inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather"); 
context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${berlinStationId}"), inject&lt;QNetworkAccessManager&gt;()), "berlinWeather"); 
</pre><h2><a class="anchor" id="autotoc_md12"></a>
Order of lookup</h2>
<p>Whenever a <em>placeholder</em> shall be looked up, the ApplicationContext will search the following sources, until it can resolve the <em>placeholder</em>:</p>
<ol type="1">
<li>The environment, for a variable corresponding to the <em>placeholder</em>.</li>
<li>The instances of <code>QSettings</code> that have been registered in the ApplicationContext.</li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
Configuring values of non-String types</h2>
<p>With <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>, you can also process arguments of types other than <code>QString</code>. You just need to specify the template-argument explicitly, or pass a default-value to be used when the expression cannot be resolved.</p>
<p>Let's say there was an argument of type <code>int</code> that specified the connection-timeout in milliseconds. Then, the service-declaration would be: </p><pre class="fragment">auto decl = service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${hamburgStationId}"), resolve&lt;int&gt;("${connectionTimeout}"), inject&lt;QNetworkAccessManager&gt;());
</pre><p>You will notice the explicit type-argument used on <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>. Needless to say, the configured value for the key "connectionTimeout" must resolve to a valid integer-literal!</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Specifying default values</h2>
<p>Sometimes, you may want to provide a constructor-argument that can be externally configured, but you are unsure whether the configuration will always be present at runtime.</p>
<p>There are two ways of doing this:</p>
<ol type="1">
<li>You can supply a default-value to the function-template <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a> as its second argument: <code>resolve("${connectionTimeout}", 5000)</code>. This works only for constructor-arguments (see <a class="el" href="#constructor-arguments">Using Constructor-arguments</a>).</li>
<li>You can put a default-value into the placeholder-expression, separated from the placeholder by a colon: <code>"${connectionTimeout:5000}"</code>. Such an embedded default-value takes precedence over one supplied to mqnepp::qtdi::resolve(). This works for both constructor-arguments and Q_PROPERTYs (see <a class="el" href="#configuring-services">Configuring services with Q_PROPERTY</a>).</li>
</ol>
<h2><a class="anchor" id="autotoc_md15"></a>
Specifying an explicit Group</h2>
<p>If you structure your configuration in a hierarchical manner, you may find it useful to put your configuration-values into a <code>QSettings::group()</code>. Such a group can be specified for your resolvable values by means of the <a class="el" href="qapplicationcontext_8h.html#a64ec1392974a8374f34bfff59fc43a8e" title="Sets the group for a service_config.  The usage of this function is analogous to that of iostream-man...">mcnepp::qtdi::withGroup(const QString&amp;)</a> function. In the following example, the configuration-keys "baseUrl", "hamburgStationId" and "connectionTimeout" are assumed to reside in the group named "mcnepp": </p><pre class="fragment">auto decl = ;
appContext -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${hamburgStationId}"), resolve&lt;int&gt;("${connectionTimeout}"), inject&lt;QNetworkAccessManager&gt;())
&lt;&lt; withGroup("mcnepp"), 
"hamburgWeather");
</pre><h2><a class="anchor" id="autotoc_md16"></a>
Lookup in sub-sections</h2>
<p>Every key will be looked up in the section that has been provided via as an argument to <a class="el" href="qapplicationcontext_8h.html#a64ec1392974a8374f34bfff59fc43a8e" title="Sets the group for a service_config.  The usage of this function is analogous to that of iostream-man...">mcnepp::qtdi::withGroup(const QString&amp;)</a>, argument, unless the key itself starts with a forward slash, which denotes the root-section.</p>
<p>A special syntax is available for forcing a key to be looked up in parent-sections if it cannot be resolved in the provided section: Insert <code>*/</code> right after the opening sequence of the placeholder. </p><pre class="fragment">context -&gt; registerService(service&lt;QIODevice,QFile&gt;(resolve("${*/filename}")) &lt;&lt; withGroup("files"), "file");
</pre><p>The key "filename" will first be searched in the section "files". If it cannot be found, it will be searched in the root-section.</p>
<h1><a class="anchor" id="configuring-services"></a>
Configuring properties of services</h1>
<p>We have seen how we can inject configuration-values into Service-constructors. <br  />
However, a service may have additional dependencies or configuration-values that need to be supplied after construction. <br  />
For this purpose, there are various overloads of <a class="el" href="structmcnepp_1_1qtdi_1_1_service.html#ab08828a9cae2e021ffc10ca3bc58b75e" title="Adds a type-safe configuration-entry to this Service.">mcnepp::qtdi::Service::operator&lt;&lt;()</a>.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
Using Q_PROPERTY</h2>
<p>One way of configuring services is to use its <code>Q_PROPERTY</code> declarations. Suppose we modify the declaration of <code>RestPropFetcher</code> like this: </p><pre class="fragment">class RestPropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(QString url READ url WRITE setUrl NOTIFY urlChanged)

  Q_PROPERTY(int connectionTimeout READ connectionTimeout WRITE setConnectionTimeout NOTIFY connectionTimeoutChanged)


  public:

  explicit RestPropFetcher(QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  QString value() const;

  QString url() const;

  void setUrl(const QString&amp;);

  void setConnectionTimeout(int);

  int connectionTimeout() const;

  signals:

  void valueChanged();
  void urlChanged();
  void connectionTimeoutChanged();
};
</pre><p>Now, the "url" cannot be injected into the constructor. Rather, it must be set explicitly via the corresponding Q_PROPERTY. In order to achieve this, we must add configuration-entries to the service. We use the left-shift operator <code>&lt;&lt;</code> for this, as shown below: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "${baseUrl}?stationIds=${hamburgStationId}") &lt;&lt; propValue("connectionTimeout", "${connectionTimeout:5000}"), "hamburgWeather");
context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "${baseUrl}?stationIds=${berlinStationId}") &lt;&lt; propValue("connectionTimeout", "${connectionTimeout:5000}"), "berlinWeather"); 
</pre><p>As you can see, the code has changed quite significantly: instead of supplying the Url as a constructor-argument, you pass in the key/value-pairs for configuring the service's url and connectionTimeouts as Q_PROPERTYs.</p>
<p><b>Note:</b> Every <a class="el" href="qapplicationcontext_8h.html#a46b0c6ddcf667b2b9a22b772912f38c7" title="Creates a type-safe configuration-entry for a service.  The resulting service_config_entry can then b...">mcnepp::qtdi::propValue()</a> supplied to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> will be considered a potential <code>Q_PROPERTY</code> of the target-service. <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> will fail if no such property can be found. <br  />
 However, if you use <a class="el" href="qapplicationcontext_8h.html#a95e9c49e39e4fcbe28ceca48da71dcd1" title="Creates a configuration-entry for a service.  The resulting service_config_entry can then be passed t...">mcnepp::qtdi::placeholderValue()</a> instead, it will still be resolved via QSettings, but no attempt will be made to access a matching Q_PROPERTY. Such <em>placeholder-value</em> may be passed to a <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(servic...">mcnepp::qtdi::QApplicationContextPostProcessor</a> (see section <a class="el" href="#tweaking-services">Tweaking services</a> below).</p>
<p>Also, <em>placeholder-value</em> can be very useful in conjunction with <a class="el" href="#service-templates">Service-templates</a>.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Configuring services with type-safe 'setters'</h2>
<p>In the previous paragraph, you could see how Q_PROPERTYs of the services were initialized using the property-names. <br  />
Now, we will show arbitrary service-properties can be configured, even if no Q_PROPERTY has been declared. <br  />
Instead of using the property-name, we'll reference the member-function that sets the value. <br  />
We use one of the various overloads of <a class="el" href="qapplicationcontext_8h.html#a46b0c6ddcf667b2b9a22b772912f38c7" title="Creates a type-safe configuration-entry for a service.  The resulting service_config_entry can then b...">mcnepp::qtdi::propValue()</a> in order to create a type-safe configuration-entry. <br  />
Here is an example setting the <code>transferTimeout</code> of a QNetworkAccessManager. This property is not declared with the Q_PROEPRTY macro, thus, it cannot be set using the QMetaType-system: </p><pre class="fragment">context -&gt; registerService(service&lt;QNetworkAccessManager&gt;() &lt;&lt; propValue(&amp;QNetworkAccessManager::setTransferTimeout, 5000), "networkManager"); 
</pre><p><br  />
Using <em>setters</em> can, of course, be combined with resolving configuration-values: </p><pre class="fragment">context -&gt; registerService(service&lt;QNetworkAccessManager&gt;() &lt;&lt; propValue(&amp;QNetworkAccessManager::setTransferTimeout, "${transferTimeout}"), "networkManager"); 
</pre><h2><a class="anchor" id="autotoc_md19"></a>
Auto-refreshable configuration-values</h2>
<p>If you configure a Q_PROPERTY using <a class="el" href="qapplicationcontext_8h.html#a46b0c6ddcf667b2b9a22b772912f38c7" title="Creates a type-safe configuration-entry for a service.  The resulting service_config_entry can then b...">mcnepp::qtdi::propValue()</a>, the property of the Service-Object will be set exactly once, immediately after creation, right before any <a class="el" href="#service-initializers">service-initializers</a> may be invoked. After that, the service will be published. <br  />
There may be times, however, when you want a property to be refreshed automatically every time the value in the corresponding QSettings-object changeds. <br  />
This can be achieved by using <a class="el" href="qapplicationcontext_8h.html#aecd6c0272cea03116803d76f12e40157" title="Specifies that a value for a configured Q_PROPERTY shall be automatically updated at runtime....">mcnepp::qtdi::autoRefresh(const QString&amp;,const QString&amp;)</a>. <br  />
The following line will configure a QTimer's <code>interval</code> using an auto-refreshable configuration-value: </p><pre class="fragment">context-&gt;registerService(service&lt;QTimer&gt;() &lt;&lt; autoRefresh("interval", "${timerInterval}"), "timer");
</pre><p>In case the configured QSettings-object uses a file as its persistent storage, any change to that file will be immediately detected. It will lead to a re-evaluation of the property. In case the configured QSettings-object uses a different persistent storage (such as the Windows Registry), the changes will be polled periodically. <br  />
Auto-refresh will also work with more complex expressions for the property. In the following example, the property <code>objectName</code> will be automatically refreshed when either one of the configuration-values <code>prefix</code> or <code>suffix</code> is modified: </p><pre class="fragment">context-&gt;registerService(service&lt;QTimer&gt;() &lt;&lt; autoRefresh("objectName", "timer-${prefix}${suffix}"), "timer");
</pre><p>In case all properties for one service shall be auto-refreshed, there is a more concise way of specifying it: </p><pre class="fragment"> context-&gt;registerService(service&lt;QTimer&gt;() &lt;&lt; withAutoRefresh &lt;&lt; propValue("objectName", "theTimer") &lt;&lt; propValue("interval", "${timerInterval}"), "timer");
</pre><p><b>Note:</b> Auto-refresh will be disabled by default in <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext. Using this class is the &quot;canonical way&quot; of ...">mcnepp::qtdi::StandardApplicationContext</a>. <br  />
It must be explicitly enabled by putting the following configuration-entry into one of the QSettings-objects registered with the context: </p><pre class="fragment">[qtdi]
enableAutoRefresh=true
; Optionally, specify the refresh-period:
autoRefreshMillis=2000
</pre><p>Auto-refreshable properties can also be specified using <em>setters</em>: </p><pre class="fragment">context-&gt;registerService(service&lt;QTimer&gt;() &lt;&lt; autoRefresh(&amp;QTimer::setInterval, "${timerInterval}"), "timer");
</pre><h1><a class="anchor" id="autotoc_md20"></a>
Service-prototypes</h1>
<p>As shown above, a service that was registered using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> will be instantiated once <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a> is invoked. <br  />
A single instance of the service will be injected into every other service that depends on it.</p>
<p>However, there may be some services that cannot be shared between dependent services. In this case, use <a class="el" href="qapplicationcontext_8h.html#a2438ec3e3e81944f1c8c8eeee580998d" title="Creates a Service-prototype with the default service-factory.">mcnepp::qtdi::prototype()</a> instead of <a class="el" href="qapplicationcontext_8h.html#a45251145dd09691a5b6ca160b1b3e6ac" title="Creates a Service with an explicit factory.">mcnepp::qtdi::service()</a> as an argument to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>. <br  />
Such a registration will not necessarily instantiate the service on <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a>. Only if there are other services depending on it will a new instance be created and injected into the dependent service.</p>
<p>Every instance of a service-protoype that gets injected into a dependent service will be made a QObject-child of the dependent service. In other words, the dependent service becomes the <em>owner</em> of the prototype-instance.</p>
<p>The same is true for <em>references to other members</em>: if a protoype is referenced via the ampersand-syntax, the instance of that prototype will be made a child of the service that references it.</p>
<h1><a class="anchor" id="service-templates"></a>
Service-templates</h1>
<p>A service-template is a recipe for configuring a service without actually registering a concrete service. Such a template can then be re-used when further concrete services are registered. <br  />
(For those familiar with Spring-DI: this would be an <em>"abstract"</em> bean-definition). <br  />
A Service-template can be registered like this: </p><pre class="fragment">auto restFetcherTemplateRegistration = context -&gt; registerService(serviceTemplate&lt;RestPropFetcher&gt;()
    &lt;&lt; propValue("connectionTimeout", "${connectionTimeout:5000}")
    &lt;&lt; propValue("url", "${baseUrl}?stationIds=${stationId}"),
"fetcherBase");
</pre><p><br  />
The return-value has the type <code>ServiceRegistration&lt;RestPropFetcher,ServiceScope::TEMPLATE&gt;</code>. It can be supplied as an additional argument to subsequent registrations: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;() &lt;&lt; placeholderValue("stationId", "10147"), restFetcherTemplateRegistration, "hamburgWeather");
</pre><p>If a service-registration utilizes a service-template, the type of the registered service must be implicitly convertible to the service-template's type. In particular, it can be the same type (as can be seen in the example above).</p>
<p>Service-templates have the following capabilities:</p>
<ol type="1">
<li>Uniform configuration. You may configure Q_PROPERTYs in a uniform way for all services that use this template. See the property <code>connectionTimeout</code> in the above example, which will be set to the same value for every service derived from this template. Even more interesting is the use of the placeholder <code>${stationId}</code> in the template's configuration. It will be resolved by use of a <em>placeholder-value at the registration of the concrete service.</em></li>
<li><em>Init-Methods. You may specify an *init-method</em> via the <code><a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a></code> of the service-template.</li>
<li>Uniform advertising of service-interfaces. You may once specify the set of interfaces that a service-template advertises. That way, you don't need to repeat this for every service that uses the template. (See section <a class="el" href="#service-interfaces">Service-interfaces</a> below).</li>
</ol>
<h2><a class="anchor" id="autotoc_md21"></a>
Generic (un-validated) properties of Service-templates</h2>
<p>Registration of a service-template differs from the registration of a "normal" service in one important aspect:</p>
<p>The properties that you provide via <a class="el" href="qapplicationcontext_8h.html#a45251145dd09691a5b6ca160b1b3e6ac" title="Creates a Service with an explicit factory.">mcnepp::qtdi::service()</a> will not be validated against the Q_PROPERTYs of the service's implementation-type!</p>
<p>The rationale is that the service-template may be used by services of yet unknown type. The validation of a Q_PROPERTY will therefore be postponed until registration of the concrete service that derives from this service-template.</p>
<p>This makes it possible to register configured service-templates without assuming any particular service-type at all! <br  />
In order to facilitate this, the type-argument of the function <a class="el" href="qapplicationcontext_8h.html#a1dc51a0152614fb643aaf888bf901eae" title="Creates a Service-template with no dependencies and no constructor.  The returned Service cannot be i...">mcnepp::qtdi::serviceTemplate()</a> has a default-type of <code>QObject</code>.</p>
<p>Using this knowledge, let's register a service-template for arbitrary services that support a Q_PROPERTY <code>url</code>:</p>
<pre class="fragment">auto urlAware = context-&gt;registerService(serviceTemplate() &lt;&lt; propValue("url", "http://github.com"), "urlAware");
</pre><h1><a class="anchor" id="autotoc_md22"></a>
Managed Services vs. Un-managed Objects</h1>
<p>The function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> that was shown in the preceeding example results in the creation of a <code>managed service</code>. <br  />
 The entire lifecylce of the registered Service will be managed by the QApplicationContext. <br  />
 Sometimes, however, it will be necessary to register an existing QObject with the ApplicationContext and make it available to other components as a dependency. <br  />
 A reason for this may be that the constructor of the class does not merely accept other <code>QObject</code>-pointers (as "dependencies"), but also <code>QString</code>s or other non-QObject-typed value. <br  />
 A good example would be registering objects of type <code>QSettings</code>, which play an important role in <a class="el" href="#externalized-configuration">Externalized Configuration</a>. <br  />
</p>
<p>There are some crucial differences between <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>, when invoked with either <a class="el" href="qapplicationcontext_8h.html#a45251145dd09691a5b6ca160b1b3e6ac" title="Creates a Service with an explicit factory.">mcnepp::qtdi::service()</a> or <a class="el" href="qapplicationcontext_8h.html#a2438ec3e3e81944f1c8c8eeee580998d" title="Creates a Service-prototype with the default service-factory.">mcnepp::qtdi::prototype()</a>. Also, there are differences to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5ddf9204ec6f0071793adb3c770bc3ab" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>, as the following table shows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">registerService(service())   </th><th class="markdownTableHeadNone">registerService(prototype())   </th><th class="markdownTableHeadNone">registerObject    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Instantiation of the object   </td><td class="markdownTableBodyNone">Upon <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>   </td><td class="markdownTableBodyNone">In <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>,<br  />
but only if another service requests it   </td><td class="markdownTableBodyNone">Prior to the registration with the QApplicationContext    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">When is the signal <code>objectPublished(QObject*)</code> emitted?   </td><td class="markdownTableBodyNone">Upon <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>   </td><td class="markdownTableBodyNone">In <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>,<br  />
but only if another service requests it   </td><td class="markdownTableBodyNone">Immediately after the registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Naming of the QObject   </td><td class="markdownTableBodyNone" colspan="2"><code>QObject::objectName</code> is set to the name of the registration   </td><td class="markdownTableBodyNone"><code>QObject::objectName</code> is not touched by QApplicationContext    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Handling of Properties   </td><td class="markdownTableBodyNone" colspan="2">The key/value-pairs supplied at registration will be set as Q_PROPERTYs by QApplicationContext   </td><td class="markdownTableBodyNone">All properties must be set before registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Processing by <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(servic...">mcnepp::qtdi::QApplicationContextPostProcessor</a>   </td><td class="markdownTableBodyNone" colspan="2">Every service will be processed by the registered QApplicationContextPostProcessors   </td><td class="markdownTableBodyNone">Object is not processed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Invocation of <em>init-method</em>   </td><td class="markdownTableBodyNone" colspan="2">If present, will be invoked by QApplicationContext   </td><td class="markdownTableBodyNone">If present, must have been invoked prior to registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Parent/Child-relation   </td><td class="markdownTableBodyNone">If a Service has no parent after its <em>init-method</em> has run, the ApplicationContext will become the service's parent.   </td><td class="markdownTableBodyNone">The instance of the prototype will be made a child of the service that required it.   </td><td class="markdownTableBodyNone">The parent of the Object will not be touched.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Destruction of the object   </td><td class="markdownTableBodyNone">Upon destruction of the QApplicationContext   </td><td class="markdownTableBodyNone">Upon destruction of the Service that owns the prototype-instance.   </td><td class="markdownTableBodyNone">At the discrection of the code that created it   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md23"></a>
Types of dependency-relations</h1>
<p>In our previous example, we have seen the dependency of our <code>RestPropFetcher</code> to a <code>QNetworkAccessManager</code>. <br  />
 This constitutes a <em>mandatory dependency</em>: instantion of the <code>RestPropFetcher</code>will fail if no <code>QNetworkAccessManager</code>can be found. However, there are more ways to express a dependency-relation. <br  />
 This is reflected by the enum-type <code><a class="el" href="qapplicationcontext_8h.html#a3105526e127bde2871f257823d62db7b">mcnepp::qtdi::DependencyKind</a></code> and its enum-constants as listed below:</p>
<h2><a class="anchor" id="autotoc_md24"></a>
MANDATORY</h2>
<p>As stated before, mandatory dependencies enforce that there is exactly one service of the dependency-type present in the ApplicationContext. Otherwise, publication will fail. Mandatory dependencies can be specified by using inject(): </p><pre class="fragment">context-&gt;registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()));
</pre><p>In case you have the ServiceRegistration for the dependency at hand, you may skip the invocation of <a class="el" href="qapplicationcontext_8h.html#a7f1f15461634592926ae1efd11f50ea6" title="Injects a mandatory Dependency.  This will instruct the ApplicationContext to find exactly one Depend...">mcnepp::qtdi::inject()</a> and use the ServiceRegistration directly:</p>
<p>....auto networkRegistration = context-&gt;registerService&lt;QNetworkAccessManager&gt;(); context-&gt;registerService(service&lt;RestPropFetcher&gt;(networkRegistration));</p>
<h2><a class="anchor" id="autotoc_md25"></a>
OPTIONAL</h2>
<p>A service that has an <em>optional dependency</em> to another service may be instantiated even when no matching other service can be found in the ApplicationContext. In that case, <code>nullptr</code> will be passed to the service's constructor. <br  />
 Optional dependencies are specified using the function <a class="el" href="qapplicationcontext_8h.html#a62777d7ae6b38c128de21de31f22ac5a" title="Injects an optional Dependency.  This will instruct the ApplicationContext to find exactly one Depend...">mcnepp::qtdi::injectIfPresent()</a>. Suppose it were possible to create our <code>RestPropFetcher</code> without a <code>QNetworkAccessManage</code>: </p><pre class="fragment">context-&gt;registerService(service&lt;RestPropFetcher&gt;(injectIfPresent&lt;QNetworkAccessManager&gt;()));
</pre><p>When the Service is later created, the ApplicationContext will look for another Service of type <code>QNetworkAccessManager</code>. If exactly one matching Service is found, it will be injected into the <code>RestPropFetcher</code>. Otherwise, <code>nullptr</code> will be injected.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
N (one-to-many)</h2>
<p>Now, let's extend our example a bit: we want to create a component that shall receive the fetched values from all RestPropFetchers and somehow sum them up. Such a component could look like this: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;RestPropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p>Note that the above component comprises a one-to-,any relationship with its dependent components. We must notify the QApplicationContext about this, so that it can correctly inject all the matching dependencies into the component's constructor. <br  />
 The following statement will do the trick: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;RestPropFetcher&gt;()), "propFetcherAggregation");
</pre><p><b>Note:</b>, while constructing the <code>QList</code> with dependencies, the ordering of registrations of <b>non-interdependent services</b> will be honoured as much as possible. In the above example, the services "hamburgWeather" and "berlinWeather" will appear in that order in the <code>QList</code> that is passed to the <code>PropFetcherAggreator</code>.</p>
<p>In case you have the ProxyRegistration for the dependency at hand, you may skip the invocation of <a class="el" href="qapplicationcontext_8h.html#a7f1f15461634592926ae1efd11f50ea6" title="Injects a mandatory Dependency.  This will instruct the ApplicationContext to find exactly one Depend...">mcnepp::qtdi::inject()</a> and use the ProxyRegistration directly:</p>
<p>....auto networkRegistration = context-&gt;getRegistration&lt;QNetworkAccessManager&gt;(); context-&gt;registerService(service&lt;PropFetcherAggregator&gt;(networkRegistration));</p>
<p>The following table sums up the characteristics of the different types of dependencies:</p>
<table class="doxtable">
<tr>
<th>&#160;</th><th>Normal behaviour</th><th>What if no dependency can be found?</th><th>What if more than one dependency can be found? </th></tr>
<tr>
<td>MANDATORY</td><td>Injects one dependency into the dependent service.</td><td>Publication of the ApplicationContext will fail. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
<tr>
<td>OPTIONAL</td><td>Injects one dependency into the dependent service</td><td>Injects <code>nullptr</code> into the dependent service. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
<tr>
<td>N</td><td>Injects all dependencies of the dependency-type that have been registered into the dependent service, using a <code>QList</code> </td><td>Injects an empty <code>QList</code> into the dependent service. </td><td>See 'Normal behaviour' </td></tr>
</table>
<h1><a class="anchor" id="service-interfaces"></a>
Service-interfaces</h1>
<p>In the preceeding example, we have registered our QObject-derived class <code>RestPropFetcher</code> directly, using the function template <a class="el" href="qapplicationcontext_8h.html#a45251145dd09691a5b6ca160b1b3e6ac" title="Creates a Service with an explicit factory.">mcnepp::qtdi::service()</a> with one type-argument (aka <code>"service&lt;RestPropFetcher&gt;()"</code>).<br  />
 Such a registration will register the implementation-type <code>RestPropFetcher</code> with the same service-interface. <br  />
We have also specified the class as the dependency-type for <code>PropFetcherAggregator</code>. <br  />
 However, in most complex applications you will likely use an abstract base-class (or 'interface'). Additionally, this interface need not be derived from QObject! <br  />
 This is well supported by QApplicationContext. First, let's declare our interface: </p><pre class="fragment">class PropFetcher  {

  public:

  virtual QString value() const = 0;

  virtual ~PropFetcher() = default;
};
</pre><p>Then, we modify our class <code>RestPropFetcher</code> so that it derives from both QObject and this interface: </p><pre class="fragment">class RestPropFetcher : public QObject, public PropFetcher {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(QString url READ url WRITE setURl NOTIFY urlChanged)

  public:

  explicit RestPropFetcher(QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  virtual QString value() const override;

  QString url() const;

  void setUrl(const QString&amp;);

  signals:

  void valueChanged();

  void urlChanged();
};
</pre><p>Having done this, we will now register the <code>RestPropFetcher</code> with the <em>service-interface</em> <code>PropFetcher</code>: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()));
</pre><p>As you can see, there are now two type-arguments: the first one being the service-interface, the second being the implementation-type.</p>
<p>What would you do if you wanted to advertise the service with more than one service-interface? Well, you use the form with one type-argument again, but then have it followed by a call to <code>advertiseAs()</code>, which accepts an arbitrary number of interface-types!</p>
<p>Here's what that would look like: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher&gt;());
</pre><p>In order to make use of our interface, we modify our class <code>PropFetcherAggregator</code> so that it accepts dependencies of the interface-type: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p>Putting it all together, we use the helper-template <code>Service</code> for specifying both an interface-type and an implementation-type:</p>
<pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardQApplicationContext; 

context -&gt; registerService&lt;QNetworkAccessManager&gt;();

context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAllOf&lt;PropFetcher&gt;()), "propFetcherAggration");

/*2*/ context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher&gt;() &lt;&lt; propValue("url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"), "hamburgWeather"); 

context -&gt; publish(); 
</pre><p><b>Note:</b> The order of registrations has been switched: now, the dependent service <code>PropFetcherAggregator</code> is registered before the services it depends on. This was done to demonstrate that, <b>regardless of the ordering of registrations</b>, the dependencies will be resolved correctly! Also, there are two type-arguments for the Service now: the first specifies the type of service-interface, the second the implementation-type.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Multiple service-interfaces</h2>
<p>A service may be advertised under more than one service-interface. This makes sense if the service-type implements several non-QObject interfaces that other services depend on. Suppose the class <code>RestPropFetcher</code> implements an additional interface <code>QNetworkManagerAware</code>: </p><pre class="fragment">class QNetworkManagerAware {
   virtual ~QNetworkManagerAware() = default;

   virtual setNetworkManager(QNetworkAccessManager*) = 0;
};

class PropFetcher : public QObject, public QNetworkManagerAware {

explicit PropFetcher(const QString&amp; url, QObject* parent = nulptr);

virtual setNetworkManager(QNetworkAccessManager*) override;
...//same as before
};

class RestPropFetcher : public PropFetcher, public QNetworkManagerAware {
...
};
</pre><p>In order to advertise a <code>RestPropFetcher</code> as both a <code>PropFetcher</code> and a <code>QNetworkManagerAware</code>, we use: </p><pre class="fragment">auto reg = context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher,QNetworkManagerAware&gt;() &lt;&lt; propValue("url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"), "hamburgWeather"); 
</pre><p><b>Note:</b> The return-value <code>reg</code> will be of type <code>ServiceRegistration&lt;RestPropFetcher,ServiceScope::SINGLETON&gt;</code>.</p>
<p>You may convert this value to <code>ServiceRegistraton&lt;PropFetcher,ServiceScope::SINGLETON&gt;</code> as well as <code>ServiceRegistration&lt;QNetworkManagerAware,ServiceScope::SINGLETON&gt;</code>, using the member-function ServiceRegistration::as(). Conversions to other types will not succeed.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Profiles</h1>
<p>Every ApplicationContext has one or more <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a087e667e535be79c5c968f48bc031441" title="What profiles are active?  Obtains the profiles that have been activated for this ApplicationContext....">mcnepp::qtdi::QApplicationContext::activeProfiles()</a>.</p>
<p>If not otherwise specified, there is one active profile name <code>"default"</code>. When using a <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext. Using this class is the &quot;canonical way&quot; of ...">mcnepp::qtdi::StandardApplicationContext</a>, the <em>active profiles</em> can be set by putting an entry with the key <code>"qtdi/activeProfiles"</code> into the ApplicationContext's configuration.</p>
<p>When registering a Service, you may specify one or more profiles for which the Service shall be active. If you supply an empty set (which is the default), the Service will be active always.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
Registering optional services</h2>
<p>With the help of Profiles, it becomes possible to register some some services that will be instantiated only if a certain profile is active. <br  />
For example, in addition to the existing service "hamburgWeather", you may register an additional <code>RestPropFetcher</code> named "munichWeather" that will be instantiated only if the profile <code>"bavaria"</code> is activated: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher,QNetworkManagerAware&gt;() &lt;&lt; propValue("url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"), "hamburgWeather");

context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher,QNetworkManagerAware&gt;() &lt;&lt; propValue("url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10870"), 
"munichWeather",
{"bavaria"}); 
</pre><h2><a class="anchor" id="autotoc_md30"></a>
Registering alternative services</h2>
<p>With the help of profiles, you may circumvent the usual restriction regarding the uniqueness of service-names: <br  />
You may indeed register two different Services under the same name - provided their list of profiles is disjunct.</p>
<p>One handy application is the registration of <em>Mock-Services</em>. Given the above interface <code>PropFetcher</code>, you may want to use a Mock-implementation if your REST-Endpoint is not available.</p>
<p>Let's recap the "normal" registration of a <code>RestPropFetcher</code>, advertised under the interface <code>PropFetcher</code>: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"), 
"hamburgWeather"); 
</pre><p>If you want to register an alternative <em>Mock-Service</em> , this will be the necessary code: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"),
"hamburgWeather",
{"default"}); // 1

context -&gt; registerService(service&lt;PropFetcher,MockPropFetcher&gt;(), "hamburgWeather", {"mock"}); // 2
</pre><ol type="1">
<li>Added an explicit profile as the last argument to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>. In this case, we use the default-profile.</li>
<li>Registered a second service under the same name and advertised using the same interface. This is only possible because we are using a different profile <code>"mock"</code>.</li>
</ol>
<p>With everything else untouched, the application will behave exactly as before. The profile <code>"default"</code>will be active, and a Service with implementation-type <code>RestPropFetcher</code> will be created. <br  />
However, if we change the <em>active profile</em> to "mock", an instance of implementation-type <code>MockPropFetcher</code> will be instantiated instead!</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Profile-specific configuration-entries</h2>
<p>Sometimes, you may want to configure your Services differently, based on the <em>active profiles</em>. <br  />
One possible way of doing this has been shown above: you could register different Services for different profiles. <br  />
However, QApplicationContext offers a much easier way: the lookup of configuration-entries will automatically take into account the <em>active profiles</em>, preferring profile-specific entries of generic ones. <br  />
This is how it works:</p><ul>
<li>For every QSettings-Object that has been registered, the configuration-entry <code>"qtdi/enableProfileSpecificSettings"</code> will be inspected. If that is <code>true</code>, then for each active profile, an additional QSettings-Object will be created internally.</li>
<li>The new QSettings will have the same QSettings::format() as the ones they are based on.</li>
<li>In case the QSettings::applicationName() is present, the new QSettings will have the same QSettings::organizationName() and QSettings::scope() as the original one. As its QSettings::applicationName(), it will get the concatenation of the original name with a dash and the name of the active profile.</li>
<li>Should no QSettings::applicationName() be present, the QSettings::fileName() will be used to construct a new QSettings-Object. Its fileName() will be comprised of the base-name with a dash and the name of the active profile, followed by the original suffix.</li>
</ul>
<p>Example: Suppose you are registering a QSettings with </p><pre class="fragment">scope: UserScope
format: NativeFormat
organizationName: mycompany
applicationName: thesuperapp
</pre><p>You set the <em>active profiles</em> to <code>{"default", "headless", "productive"}</code>.</p>
<p>Suppose a configuration-entry <code>baseUrl</code> shall be resolved. It will now be looked up in the following sequence, until it has been resolved:</p>
<ol type="1">
<li><code>mycompany/thesuperapp-headless/baseUrl</code></li>
<li><code>mycompany/thesuperapp-productive/baseUrl</code></li>
<li><code>mycompany/thesuperapp/baseUrl</code></li>
</ol>
<p><b>Note:</b> The lookup-sequence will not change when remove <code>"default"</code> from the set of <em>active profiles</em>!</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Configuring the active profiles</h2>
<p>If the environment variable <code>QTDI_ACTIVE_PROFILES</code> is defined, its value will determine the <em>active profiles</em> of each newly constructed ApplicationContext. <br  />
<b>Note:</b> Changing the value of the environment variable will have no impact on already constructed ApplicationContexts. <br  />
The <em>active profiles</em> may be overwritten through configuration-entries: From every QSettings registered with an ApplicationContext, the following entry will be read: </p><pre class="fragment">[qtdi]
activeProfiles=mock
</pre><p>The value for the entry will be read, converted to a QStringList and appended to the ApplicationContext's <em>active profiles</em>. <br  />
If neither the environment variable <code>QTDI_ACTIVE_PROFILES</code> is defined nor an entry <code>"qtdi/activeProfiles"</code> found, the <em>active profile</em> will be "default". <br  />
You may also set the active profiles programmatically using <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html#a2b13f5bafcad8e76f44d2e8f7098a135" title="Sets the active Profiles.  Invoking this method will overrule any profiles determined by the configur...">mcnepp::qtdi::StandardApplicationContext::setActiveProfiles()</a>. <br  />
<b>Note:</b> The active profiles can be changed only as long as no profile-dependent services have been published! Any attempt at doing otherwise will fail and result in an error logged.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Detection of ambiguous registrations</h2>
<p>As stated before, profiles offer a way to register more than one service with the same name - something that is strictly forbidden otherwise.</p>
<p>However, the set of profiles for which those services are registered must be <em>disjunct</em>. Some examples of that will fail at registration-time: </p><pre class="fragment">context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"default", "test"});
context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"test"});
</pre><p>The second registration will fail because if "test" were set as the <em>active profile</em> in the ApplicationContext, both registration would be active, which is forbidden. <br  />
Note that the registration will fail even though for some other profile ("default", for example) there would be no amgiguity! </p><pre class="fragment">context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"default", "test"});
context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"test", "default"});
</pre><p>The second registration will fail because the set of profiles is the same as for the first registration. The order of the profiles is irrelevant.</p>
<pre class="fragment">context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"default", "test"});
context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager");
</pre><p>The second registration will fail because it would be active for <em>any profile</em>. Thus, if "test" or "default" were set as the <em>active profile</em> in the ApplicationContext, both registrations would be active, which is forbidden. <br  />
Note that the registration will fail even though for any profile other than "test" or "default" there would be no ambiguity.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
Detection of ambiguity at publication</h2>
<p>Some cases of ambiguity cannot be detected at registration-time. However, they will be caught when <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> is invoked: </p><pre class="fragment">context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"default"});
context -&gt; registerService(service&lt;QNetworkAccessManager&gt;(), "networkManager", {"test"});
context -&gt; publish();
</pre><p>The above registrations will succeed. However, if you set the <em>active profiles</em> of the ApplicationContext to <code>{"default", "test"}</code>, the invocation of <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> will fail.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Referencing other members of the ApplicationContext</h1>
<p>Sometimes, it may be necessary to inject one member of the ApplicationContext into another member not via constructor, but via a Q_PROPERTY. <br  />
 Suppose that each <code>PropFetcher</code> shall have (for whatever reason) a reference to the <code>PropFetcherAggregator</code>. <br  />
 This cannot be done via constructor-arguments, as it would constitute a dependency-circle! <br  />
 However, we could introduce a Q_PROPERTY like this: </p><pre class="fragment">class PropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(PropFetcherAggregator* summary READ summary WRITE setSummary NOTIFY summaryChanged)

  public:

  explicit PropFetcher(QObject* parent = nullptr);

  virtual QString value() const = 0;

  virtual PropFetcherAggregator* summary() const = 0;

  virtual void setSummary(PropFetcherAggregator*) = 0;

  signals:
  void valueChanged();

  void summaryChanged();
};
</pre><p>And here's how this property will be automatically set to the ApplicationContext's <code>PropFetcherAggregator</code>. Note the ampersand as the first character of the property-value, which makes this a <em>named reference to another member</em>:</p>
<pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;()), "propFetcherAggregator");

context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher(inject&lt;QNetworkAccessManager&gt;())
  &lt;&lt; propValue("url", "${weatherUrl}${hamburgStationId}")
  &lt;&lt; propValue("summary", "&amp;propFetcherAggregator"), 
"hamburgWeather");
</pre><p>By the way, if you prefer a more type-safe way of expressing a relation with another service, here is a slightly different form of configuration, using member-function-pointers and service-registrations. The effect will be exactly the same, though:</p>
<pre class="fragment">auto propFetcherReg = context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;()), "propFetcherAggregator");

context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher(inject&lt;QNetworkAccessManager&gt;())
  &lt;&lt; propValue("url", "${weatherUrl}${hamburgStationId}")
  &lt;&lt; propValue(&amp;PropFetcher::setSummary, propFetcherReg),
  "hamburgWeather");
</pre><h1><a class="anchor" id="autotoc_md36"></a>
Connecting Signals of Services to Slots</h1>
<p>Qt's core concept for creating workflow from one QObject to another is via <em>signals and slots</em>. <br  />
For example, QTimer declares the <em>signal</em> QTimer::timeout(). <br  />
Suppose we have written a class like this: </p><pre class="fragment">class Cleaner : public QObject {
    public void clean();
};
</pre><p>Given pointer <code>QTimer* timer</code> and a pointer <code>Cleaner* cleaner</code>, we would connect them like this: </p><pre class="fragment">QTimer* timer = new QTimer;
QCleaner* cleaner = new QCleaner;

QObject::connect(timer, &amp;QTimer::timeout, cleaner, &amp;Cleaner::clean);
</pre><p>Suppose we'd like to do the same thing with services that have been registered in an ApplicationContext: We want to connect a registered <code>Cleaner</code> with a registered <code>timer</code>. <br  />
However, since the ApplicationContext manages instantiation for us, we do not have immediate access to services. <br  />
But we do have access to the ServiceRegistrations! <br  />
So, given two <code>ServiceRegistrations</code>, the equivalent code would look like this: </p><pre class="fragment">ServiceRegistration&lt;QTimer&gt; timerReg = context-&gt;registerService&lt;QTimer&gt;();
ServiceRegistration&lt;QCleaner&gt; cleanerReg = context-&gt;registerService&lt;Cleaner&gt;();

timerReg.subscribe(cleaner, [cleaner](QTimer* timer) {
  cleaner.subscribe(cleaner, [timer](QCleaner* cleaner) {
    QObject::connect(timer, &amp;QTimer::timeout, cleaner, &amp;Cleaner::clean);
  };
});
</pre><p>That looks pretty ugly, right? <br  />
Luckily, the function <a class="el" href="qapplicationcontext_8h.html#a3af2e9ed942d0a2991ea109e3483c6b5" title="Connects a signal of one Service to a slot of another service.  This function is the ApplicationConte...">mcnepp::qtdi::connectServices()</a> hides all that ugly boilerplate code from us: </p><pre class="fragment">connectServices(timerReg, &amp;QTimer::timeout, cleanerReg, &amp;Cleaner::clean);
</pre><p>As you will have notices, this looks almost exactly like the original example with the pointers-to-QObjects.</p>
<h1><a class="anchor" id="autotoc_md37"></a>
Binding source-properties to target-properties of other members of the ApplicationContext</h1>
<p>In the preceeding example, we used a reference to another member for the purpose of <b>initializing</b> a Q_PROPERTY.</p>
<p>However, we might also want to <b>bind</b> a target-service's property to the corresponding source-property of another service.</p>
<p>This can be achieved using the function <a class="el" href="qapplicationcontext_8h.html#a0f11a14df333d20850559efeee464e15" title="Binds a property of one ServiceRegistration to a property from another Registration....">mcnepp::qtdi::bind()</a> like this: </p><pre class="fragment">QTimer timer1;

auto reg1 = context -&gt; registerObject(&amp;timer1, "timer1"); // 1

auto reg2 = context -&gt; registerService&lt;QTimer&gt;("timer2"); // 2

bind(reg1, "interval", reg2, "interval"); // 3

context -&gt; publish(); 

timer1.setInterval(4711); // 4
</pre><ol type="1">
<li>We register a <code>QTimer</code> as "timer1".</li>
<li>We register a second <code>QTimer</code> as "timer2".</li>
<li>We bind the property <code>interval</code> of the second timer to the first timer's propery.</li>
<li>We change the first timer's interval. This will also change the second timer's interval!</li>
</ol>
<p>This way of binding properties has the advantage that it can also be applied to ServiceRegistrations obtained via QApplicationContext::getRegistration(), aka those that represent more than one service. The source-property will be bound to every target-service automatically!</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Type-safe bindings</h2>
<p>The above binding used property-names to denote the source- and target-properties. <br  />
In case the source-service offers a signal that corresponds with the property, you can use pointers to member-functions instead, which is more type-safe. <br  />
Here is an example: </p><pre class="fragment">QTimer timer1;

auto reg1 = context -&gt; registerObject(&amp;timer1, "timer1"); // 1

auto reg2 = context -&gt; registerService&lt;QTimer&gt;("timer2"); // 2

bind(reg1, &amp;QTimer::objectNameChanged, reg2, &amp;QTimer::setObjectName); // 3

context -&gt; publish(); 

timer1.setObjectName("new Name"); // 4
</pre><ol type="1">
<li>We register a <code>QTimer</code> as "timer1".</li>
<li>We register a second <code>QTimer</code> as "timer2".</li>
<li>We bind the property <code>objectName</code> of the second timer to the first timer's propery.</li>
<li>We change the first timer's objectName. This will also change the second timer's objectName!</li>
</ol>
<h1><a class="anchor" id="autotoc_md39"></a>
Subscribing to a service after registration</h1>
<p>So far, we have published the ApplicationContext and let it take care of wiring all the components together. <br  />
 In some cases, you need to obtain a reference to a member of the Context after it has been published. <br  />
 This is where the return-value of <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> comes into play: <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a>.</p>
<p>It offers the method <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#a281f12a7c18c6793c5924a73159ff1bb" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a>, which is a type-safe version of a Qt-Signal. (It is actually implemented in terms of the Signal mcnepp::qtdi::Registration::objectPublished(QObject*)).</p>
<p>In addition to being type-safe, the method <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#a281f12a7c18c6793c5924a73159ff1bb" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a> has the advantage that it will automatically inject the service if you subscribe after the service has already been published. <br  />
 This code shows how to utilize it: </p><pre class="fragment">auto registration = context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "${weatherUrl}${hamburgStationId}"), "hamburgWeather"); 

registration.subscribe(this, [](PropFetcher* fetcher) { qInfo() &lt;&lt; "I got the PropFetcher!"; });
</pre><p>The function <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#a281f12a7c18c6793c5924a73159ff1bb" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a> does return a value of type <a class="el" href="classmcnepp_1_1qtdi_1_1_subscription.html" title="An opaque handle to a detail::Subscription. Instances of this class will be returned by Registration:...">mcnepp::qtdi::Subscription</a>. Usually, you may ignore this return-value. However, it can be used for error-checking and for cancelling a subscription, should that be necessary.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Subscribing to multiple Services</h2>
<p>As shown above, the method Registration::subscribe() is the way to go if you want to get a hold on a published service.</p>
<p>But what if you would like to do something with more than one Service?</p>
<p>Use <a class="el" href="qapplicationcontext_8h.html#ae106d702aeec65e9720e7c19821aeed4" title="Combines two ore more ServiceRegistrations.  This function returns a temporary object of type Service...">mcnepp::qtdi::combine()</a>, followed by <a class="el" href="classmcnepp_1_1qtdi_1_1_service_combination.html#a392e36cf6961cfd0a6356f2441f4ac4c" title="Subscribes to this ServiceCombination.  Note: the callable will be invoked once for every distinct co...">mcnepp::qtdi::ServiceCombination::subscribe()</a>.</p>
<p>The following example combines one service of type <code>PropFetcher</code> and one <code>QTimer</code> and invokes a member-function <code>fetch</code> with both arguments: </p><pre class="fragment">auto propFetcherRegistration = context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "${weatherUrl}${hamburgStationId}"), "hamburgWeather"); 
auto timerRegistration = context-&gt;getRegistration&lt;QTime&gt;();
combine(propFetcherRegistration, timerRegistration).subscribe(this, [this](PropFetcher* fetcher, QTimer* timer) 
  { 
     this-&gt;fetch(fetcher, timer); 
  });
</pre><h1><a class="anchor" id="autotoc_md41"></a>
Accessing published services of the ApplicationContext</h1>
<p>In the previous paragraph, we used the <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> obtained by <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>, which refers to a single member of the ApplicationContext. However, we might be interested in all services of a certain service-type. <br  />
 This can be achieved using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a9c35f37337d77fdc0e19e160d48ba569" title="Obtains a ServiceRegistration for a name.  This function will look up Services by the names they were...">mcnepp::qtdi::QApplicationContext::getRegistration()</a>, which yields a <a class="el" href="classmcnepp_1_1qtdi_1_1_proxy_registration.html" title="A Registration that manages several ServiceRegistrations of the same type. You can do almost everythi...">mcnepp::qtdi::ProxyRegistration</a> that represents <em>all services of the requested service-type</em>.</p>
<pre class="fragment">auto registration = context -&gt; getRegistration&lt;PropFetcher&gt;();
qInfo() &lt;&lt; "There have been" &lt;&lt; registration.registeredServices().size() &lt;&lt; "RestPropFetchers so far!";    
</pre><p>You may also access a specific service by name: </p><pre class="fragment">auto registration = context -&gt; getRegistration("hamburgWeather");
if(!registration) {
  qWarning() &lt;&lt; "Could not obtain service 'hamburgWeather'";
} else {
  registration.as&lt;PropFetcher&gt;().subscribe(this, [](PropFetcher* fetcher) { qInfo() &lt;&lt; "Got a PropFetcher!"; });
}
</pre><h1><a class="anchor" id="tweaking-services"></a>
Tweaking services (QApplicationContextPostProcessor)</h1>
<p>Whenever a service has been instantiated and all properties have been set, QApplicationContext will apply all registered <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(servic...">mcnepp::qtdi::QApplicationContextPostProcessor</a>`s to it. These are user-supplied QObjects that implement the aforementioned interface which comprises a single method: </p><pre class="fragment">QApplicationContextPostProcessor::process(service_registration_handle_t, QObject*,const QVariantMap&amp;)
</pre><p>In this method, you might apply further configuration to your service there, or perform logging or monitoring tasks.<br  />
 Any information that you might want to pass to a QApplicationContextPostProcessor can be supplied as a so-called <em>placeholder-value</em> via <a class="el" href="qapplicationcontext_8h.html#a95e9c49e39e4fcbe28ceca48da71dcd1" title="Creates a configuration-entry for a service.  The resulting service_config_entry can then be passed t...">mcnepp::qtdi::placeholderValue(const QString&amp;,const QVariant&amp;)</a>.</p>
<h1><a class="anchor" id="service-initializers"></a>
Service-Initializers</h1>
<p>The last step done in <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> for each service is the invocation of an <em>init-method</em>, should one have been specified.</p>
<p>The same <em>init-method</em> should be used for every service of a certain type. In order to achieve this, you need to specialize <a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a> for your service-type and declare a type-alias named <code>initializer_type</code>. <br  />
It is recommended to make use of the helper-template <a class="el" href="structmcnepp_1_1qtdi_1_1default__service__traits.html" title="Provides default-values for service_traits.  Specializations of service_traits in client-code are enc...">mcnepp::qtdi::default_service_traits</a> for this purpose, which will declare the necessary type-aliases for you:</p>
<p>A suitable type would be a callable <code>struct</code> with either one argument of the service-type, or with two arguments, the second being of type <code>QApplicationContext*</code>. </p><pre class="fragment">struct RestPropFetcher_initializer{
  void operator()(PropFetcherAggregator* service) const {
     service -&gt; init();
  }
};

namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;RestPropFetcher&gt; : default_service_traits&lt;RestPropFetcher,RestPropFetcher_initializer&gt; {
  };
}
</pre><h2><a class="anchor" id="autotoc_md42"></a>
Initialization by function-reference</h2>
<p>In the above example, the callable <code>struct RestPropFetcher_initializer</code> simply invokes the method <code>PropFetcherAggregator::init()</code>. Shouldn't we be able to get rid of the <code>struct RestPropFetcher_initializer</code> somehow? <br  />
This is indeed possible. The helper-type <a class="el" href="structmcnepp_1_1qtdi_1_1service__initializer.html" title="A helper-template that converts a pointer to a function or a pointer to a member-function into a dist...">mcnepp::qtdi::service_initializer</a> takes a pointer to a member-function and converts it into a type. That way, we can reference the member-function (almost) directly in our service_traits: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;RestPropFetcher&gt; : default_service_traits&lt;RestPropFetcher,service_initializer&lt;&amp;RestPropFetcher::init&gt;&gt; {
  };
}
</pre><h2><a class="anchor" id="autotoc_md43"></a>
Specifying initializers via interfaces</h2>
<p>Suppose that the init-method was part of the service-interface <code>PropFetcher</code> that was introduced above. </p><pre class="fragment">class PropFetcher  {

  public:

  virtual QString value() const = 0;

  virtual void init() = 0;

  virtual ~PropFetcher() = default;
};
</pre><p>We would like to specify the use of the member-function <code>PropFetcher::init()</code> for all services that implement this interface. <br  />
Well, this is how it's done: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;PropFetcher&gt; : default_service_traits&lt;PropFetcher,service_initializer&lt;&amp;PropFetcher::init&gt;&gt; {
  };
}
</pre><p>Of course, in order to take advantage of this, we must advertise our <code>RestPropFetcher</code> under the interface <code>PropFetcher</code>. <br  />
Now, if you advertise a service under more than one interface, an ambiguity could arise, in case more than one interface declares its own service_initializer. In that case, compilation will fail with a corresponding diganostic. <br  />
In order to fix this error, you should specify an initializer_type in the service_traits of the service's <em>implementation-type</em>.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Specifying initializers per Registration</h2>
<p>There is also method that lets you specify an <em>init-method</em> without the need for a specialization of <a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a>. <br  />
This will register only one specific service with the supplied <em>init-method</em>: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;RestPropFetcher&gt;()).withInit(&amp;PropFetcherAggregator::init));
</pre><p>See <a class="el" href="structmcnepp_1_1qtdi_1_1_service.html#a87a22d48165ace52ca130871ea4877fb" title="Specifies an init-method for this service.  This overrides the init-method that is deduced from the i...">mcnepp::qtdi::Service::withInit()</a></p>
<h2><a class="anchor" id="autotoc_md45"></a>
Changing the order of initialization</h2>
<p>Per default, publication of a Service is announced <b>after</b> the <em>init-method</em> has run. <br  />
However, there may be cases where you would like to subscribe to ServiceRegistrations and have the Subscription be invoked <b>before</b> the <em>init-method</em> has run. <br  />
In order to achieve this, there is the enumeration <a class="el" href="qapplicationcontext_8h.html#ab3333f19593fc561a80ae65e3d8866de" title="Determines whether a Service&#39;s init-method is invoked before or after the service is published.">mcnepp::qtdi::ServiceInitializationPolicy</a>. <br  />
You may specify a different ServiceInitializationPolicy via the service_traits. The following example will determine that Services of type PropFetcher will be announced <b>before</b> their method <code>PropFetcher::init</code> has run: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;PropFetcher&gt; : default_service_traits&lt;PropFetcher,service_initializer&lt;&amp;PropFetcher::init&gt;,ServiceInitializationPolicy::AFTER_PUBLICATION&gt; {
  };
}
</pre><p>Of course, a ServiceInitializationPolicy can also be supplied per registration, as shown here: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;RestPropFetcher&gt;()).withInit&lt;ServiceInitializationPolicy::AFTER_PUBLICATION&gt;(&amp;PropFetcherAggregator::init));
</pre><h1><a class="anchor" id="autotoc_md46"></a>
Resolving ambiguities</h1>
<p>Sometimes, multiple instances of a service with the same service-type have been registered. <br  />
 (In our previous examples, this was the case with two instances of the <code>PropFetcher</code> service-type.) <br  />
 If you want to inject only one of those into a dependent service, how can you do that? <br  />
 Well, using the name of the registered service seems like a good idea. The following code will still provide a <code>QList&lt;PropFetcher*&gt;</code> to the <code>PropFetcherAggregator</code>. However, the List will contain solely the service that was registered under the name "hamburgWeather": <br  />
 </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;("hamburgWeather")), "propFetcherAggregator");
</pre><h1><a class="anchor" id="autotoc_md47"></a>
Customizing service-instantiation</h1>
<p>So far, we have seen that each call to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> mirrors a corresponding constructor-invocation of the service-type.</p>
<p>In order for this to work, several pre-conditions must be true:</p>
<ol type="1">
<li>the constructor of the service must be accessible, i.e. declared <code>public</code>.</li>
<li>The number of mandatory arguments must match the arguments provided via <code>QApplicationContext::registerService()</code>.</li>
<li>For each mandatory or optional dependency, the argument-type must be <code>T*</code>.</li>
<li>For each dependency with cardinality N, the argument-type must be <code>QList&lt;T*&gt;</code>.</li>
</ol>
<p>If any of these conditions fails, then the invocation of <code>QApplicationContext::registerService()</code> will fail compilation.</p>
<p>Suppose that the declaration of the class <code>PropFetcherAggregator</code> has been changed in the following way: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  static PropFetcherAggregator* create(const std::vector&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);

  private:

  explicit PropFetcherAggregator(const std::vector&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p>Two things have been changed:</p>
<ol type="1">
<li>Instead of the constructor, which is now private, there is a public static factory-function "create".</li>
<li>The list of PropFetchers is supplied as a <code>std::vector</code>, not as a <code>QList</code>.</li>
</ol>
<p>Now, service-registration will fail, as <code>PropFetcherAggregator</code>'s constructor cannot be invoked.</p>
<p>Luckily, there are two ways of solving this: you can either specialize the template <a class="el" href="structmcnepp_1_1qtdi_1_1service__factory.html" title="A template that can be specialized to override the standard way of instantiating services....">mcnepp::qtdi::service_factory</a> for your service-type, or you can provide your own factory.</p>
<p>(This twofold-approach follows precedent from the standard-library, where you can either specizalize std::hash, or provide your own 'hasher' to classes such as std::unordered_set.)</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Specializing service_factory</h2>
<p>As with all such specializations, it must reside in the namespace of the primary template, i.e. <code>mcnepp::qtdi</code>.</p>
<p>The specialization must provide a call-operator that takes the arguments provided by QApplicationContext, adapts those arguments to the arguments expected by the service-type, and returns a pointer to the newly created service.<br  />
 Additionally, it should provide a type-declaration <code>service_type</code>:</p>
<p>Here is all that we have to do: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_factory&lt;PropFetcherAggregator&gt; {
    using service_type = PropFetcherAggregator;

    PropFetcherAggregator* operator()(const QList&lt;PropFetcher*&gt; fetchers) const {
      return PropFetcherAggregator::create(std::vector&lt;PropFetcher*&gt;{fetchers.begin(), fetchers.end()});
    }
  };
}
</pre><p>And, voila: We can register our service exactly as we did before!</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Provide a custom factory for the service_traits</h2>
<p>Your custom factory must provide a suitable operator(). Additionally, it should provide a type-declaration <code>service_type</code>:</p>
<pre class="fragment">  struct propfetcher_factory {
    using service_type = PropFetcherAggregator;

    PropFetcherAggregator* operator()(const QList&lt;PropFetcher*&gt; fetchers) const {
      return PropFetcherAggregator::create(std::vector&lt;PropFetcher*&gt;{fetchers.begin(), fetchers.end()});
    }
  };
}
</pre><p>This factory should now be used with every service of type <code>PropFetcherAggregator</code>. To achieve this, you declare a type-alias named <code>factory_type</code> in the <a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a>: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;PropFetcherAggregator&gt; : default_service_traits&lt;PropFetcherAggregator&gt; {
    using factory_type = propfetcher_factory;
  };
}
</pre><h2><a class="anchor" id="autotoc_md50"></a>
Use a custom factory selectively</h2>
<p>In the previous paragraph, it was shown how you declare a custom factory and register it via the <a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a>. However, there might be occasions where you want to rely on the default mechanism for constructing your service most of the times, but want to supply the custom factory occasionally. <br  />
There is an overload of <a class="el" href="qapplicationcontext_8h.html#a45251145dd09691a5b6ca160b1b3e6ac" title="Creates a Service with an explicit factory.">mcnepp::qtdi::service()</a> that does this. You simply pass an instance of the custom factory as the first argument: </p><pre class="fragment">context-&gt;registerService(service(propfetcher_factory{}, injectAll&lt;PropFetcher&gt;()));
</pre><h1><a class="anchor" id="autotoc_md51"></a>
Publishing an ApplicationContext more than once</h1>
<p>Sometimes, it may be desirable to inovoke QApplicationContext::publish(bool) more than once. Proceeding with the previous example, there may be several independent modules that each want to supply a service of type <code>PropFetcher</code>. Each of these modules will rightly assume that the dependency of type <code>QNetworkAccessManager</code> will be automatically supplied by the QApplicationContext.</p>
<p>But which module shall then invoke QApplicationContext::publish(bool)? Do we need to coordinate this with additional code? That could be a bit unwieldly. Luckily, this is not necessary.</p>
<p>Given that each module has access to the (global) QApplicationContext, you can simply do this in some initialization-code in module A: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "${weatherUrl}${hamburgStationId}"), "hamburgWeather"); 
context -&gt; publish();
</pre><p>...and this in module B: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()) &lt;&lt; propValue("url", "${weatherUrl}${berlinStationId}"), "berlinWeather"); 
context -&gt; publish();
</pre><p>At the first <code>publish()</code>, an instance of <code>QNetworkAccessManager</code> will be instantiated. It will be injected into both <code>RestPropFetchers</code>.</p>
<p>This will work <b>regardless of the order in which the modules are initialized</b>!</p>
<p>Now let's get back to our class <code>PropFetcherAggregator</code> from above. We'll assume that a third module C contains this initialization-code: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;()), "propFetcherAggregator");
context -&gt; publish();
</pre><p>Unfortunately, this code will only have the desired effect of injecting all <code>PropFetchers</code> into the <code>PropFetcherAggregator</code> if it is executed after the code in modules A and B. Thus, we have once again introduced a mandatory order of initialization!</p>
<p>But we can do better: First, we need to tweak our class <code>PropFetcherAggregator</code> a little: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;PropFetcher*&gt;&amp; fetchers = {}, QObject* parent = nullptr);

  void addPropFetcher(PropFetcher*);
};
</pre><p>As you can see, we've added a default-value for the constructor-argument, thus made the class default-constructible. We've also added a member-function <code>addPropFetcher(PropFetcher*)</code>, which we'll put to use in the revised initialization-code in module C: </p><pre class="fragment">auto aggregatorRegistration = context -&gt; registerService&lt;PropFetcherAggregator&gt;("propFetcherAggregator"); // 1

aggregatorRegistration-&gt;autowire(&amp;PropFetcherAggregator::addPropFetcher); // 2

context -&gt; publish();
</pre><ol type="1">
<li>No need to specify the dependency anymore. Therefore, we can use the simplified overload of QApplicationContext::registerService().</li>
<li>Will cause all PropFetchers to be injected into PropFetcherAggregator.</li>
</ol>
<p>And that's all that is needed to get rid of any mandatory order of initialization of the modules A, B and C.</p>
<h1><a class="anchor" id="autotoc_md52"></a>
Publish-mode ('allowPartial')</h1>
<p>The function QApplicationContext::publish(bool) has a boolean argument <code>allowPartial</code> with a default-value of <code>false</code>. The following table shows how this argument affects the outcome of the function:</p>
<h2><a class="anchor" id="autotoc_md53"></a>
allowPartial = false:</h2>
<ul>
<li>Transactional behaviour: Only if it can be validated that all service-dependencies can be resolved will publication begin.</li>
<li>Will either publish all services or no service at all.</li>
<li>All errors that occur while publishing a service will be logged with the level QtMsgType::QtCriticalMessage.</li>
</ul>
<h2><a class="anchor" id="autotoc_md54"></a>
allowPartial = true:</h2>
<ul>
<li>Iterative behaviour: Will publish those services whose dependencies can be resolved.</li>
<li>If publication of one service is not possible reasons that may be fixed, the function will continue to publish other services. Such reasons include:<ul>
<li>unresolved dependencies (as those may be registered later).</li>
<li>unresolved config-values (as those may be configured later).</li>
</ul>
</li>
<li>Such "fixable errors" that occur while publishing a service will be logged with the level QtMsgType::QtWarningMessage.</li>
<li>If publication of one service fails for a reason that is not fixable, the function will will immediately return without attempts to publish other services. Such reasons include:<ul>
<li>ambiguous dependencies (as those cannot not be removed from the ApplicationContext).</li>
<li>non-existing names of Q_PROPERTYs.</li>
<li>syntactically erronous config-keys (such as <code>"$interval}"</code>).</li>
</ul>
</li>
<li>Such "fatal errors" that occur while publishing a service will be logged with the level QtMsgType::QtCriticalMessage.</li>
</ul>
<h1><a class="anchor" id="autotoc_md55"></a>
The global ApplicationContext</h1>
<p>In many applications, you will instantiate exactly one QApplicationContext. In that case, the static function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#abc1d419de6d4d3af4c38a8c5791edc4d" title="Obtains the global instance.  QApplicationContext&#39;s constructor will atomically install this as the g...">mcnepp::qtdi::QApplicationContext::instance()</a> is a convenient means of providing access to that single instance. <br  />
When you create a QApplicationContext, the constructor will set a global variable to the new QApplicationContext, unless it has already been set. Consequently, the first QApplicationContext that you create in your application will become the global instance. <br  />
(Please not that QCoreApplication::instance() exhibits the same behaviour.)</p>
<h1><a class="anchor" id="autotoc_md56"></a>
The implicitly registered Services</h1>
<p>There are two Services that will be implicitly available in all instances of <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext. Using this class is the &quot;canonical way&quot; of ...">mcnepp::qtdi::StandardApplicationContext</a>:</p>
<ul>
<li>The ApplicationContext itself, registered under the name "context".</li>
<li>The QCoreApplication::instance(), registered under the name "application".</li>
</ul>
<p>Both Services will have <code>ServiceScope::EXTERNAL</code>.</p>
<p>Of course, the QCoreApplication::instance() can only be registered if it has been created before the StandardApplicationContext.</p>
<p>If that is not the case, a hook will be installed that will register the QCoreApplication::instance() with the <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#abc1d419de6d4d3af4c38a8c5791edc4d" title="Obtains the global instance.  QApplicationContext&#39;s constructor will atomically install this as the g...">mcnepp::qtdi::QApplicationContext::instance()</a> later.</p>
<h1><a class="anchor" id="autotoc_md57"></a>
Multi-threading</h1>
<p>Since the class <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a> is derived from QObject, each ApplicationContext has a <em>thread-affinity</em> to the thread that created it.</p>
<p>As a consequence, there are some restrictions regarding the threads from which some of the ApplicationContext's functions may be invoked.</p>
<p>The main thing to keep in mind is this: <b>An ApplicationContext may only be modified and published in the ApplicationContext's thread.</b></p>
<p>However, any thread may safely obtain a <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> or a <a class="el" href="classmcnepp_1_1qtdi_1_1_proxy_registration.html" title="A Registration that manages several ServiceRegistrations of the same type. You can do almost everythi...">mcnepp::qtdi::ProxyRegistration</a> and subscribe to its publication-signal. The signal will be delivered using the target-thread's event-queue.</p>
<p>The following table sums this up:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function   </th><th class="markdownTableHeadNone">Allowed threads   </th><th class="markdownTableHeadNone">Remarks    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a9c35f37337d77fdc0e19e160d48ba569" title="Obtains a ServiceRegistration for a name.  This function will look up Services by the names they were...">mcnepp::qtdi::QApplicationContext::getRegistration(const QString&amp;) const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#afce592b35526eeb43682e5acab37a63b" title="Obtains a ProxyRegistration for a service-type.  In contrast to the ServiceRegistration that is retur...">mcnepp::qtdi::QApplicationContext::getRegistration() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ada1a1701309d3cd8439845eaa472b60c" title="Obtains a List of all Services that have been registered.  The ServiceRegistrations have a type-argum...">mcnepp::qtdi::QApplicationContext::getRegistrations() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ab9bee920351076344b92a8143b05da81" title="How many services have been published? This property will initially yield false, until publish(bool) ...">mcnepp::qtdi::QApplicationContext::published() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5514133528db14cb3308410984b2b2c1" title="How many services have been registered and not yet published? This property will initially yield 0....">mcnepp::qtdi::QApplicationContext::pendingPublication() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#abc1d419de6d4d3af4c38a8c5791edc4d" title="Obtains the global instance.  QApplicationContext&#39;s constructor will atomically install this as the g...">mcnepp::qtdi::QApplicationContext::instance()</a>   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a04ed0e326833ba1e76dc6a0ba3866cfe" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid ServiceRegistration.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5ddf9204ec6f0071793adb3c770bc3ab" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid ServiceRegistration.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html#af740c20f57c2c6a24ec31a5691fc5c40" title="Registers an alias for a Service.  If this function is successful, the Service can be referenced by t...">mcnepp::qtdi::ServiceRegistration::registerAlias(const QString&amp;)</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return <code>false</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#afacf8c2137a7b568249532a14f53a33f" title="Connects a service with another service from the same QApplicationContext. Whenever a service of the ...">mcnepp::qtdi::Registration::autowire()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid Subscription.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="qapplicationcontext_8h.html#a0f11a14df333d20850559efeee464e15" title="Binds a property of one ServiceRegistration to a property from another Registration....">mcnepp::qtdi::bind()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid Subscription.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">All published services will live in the ApplicationContext's thread.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md58"></a>
Extending QApplicationContext</h1>
<p>It is not possible to extend the class <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext. Using this class is the &quot;canonical way&quot; of ...">mcnepp::qtdi::StandardApplicationContext</a>, as it is <code>final</code>.</p>
<p>However, it is possible to extend the interface <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a> in your own code. You could add additional virtual functions to the extended interface, to be used by client-code: </p><pre class="fragment">class IExtendedApplicationContext : public mcnepp::qtdi::QApplicationContext { 
public:

   using QApplicationContext::QApplicationContext;    

   virtual void doSomeFancyRegistration() = 0;
};
</pre><p>Now, you could not implement this interface <code>IExtendedApplicationContext</code> in a class that already implements <code>QApplicationContext</code>, as that would constitute multiple inheritance of the same base. <br  />
The class-template <a class="el" href="classmcnepp_1_1qtdi_1_1_application_context_impl_base.html" title="Extensible Implementation of QApplicationContext.  This class provides a means of implementating the ...">mcnepp::qtdi::ApplicationContextImplBase</a> solves that problem for you. <br  />
You need to supply the type of the extended interface as a type-argument:</p>
<pre class="fragment">class ExtendedApplicationContext : public mcnepp::qtdi::ApplicationContextImplBase&lt;QApplicationContext&gt; { 
  public:
    ExtendedApplicationContext(QObject* parent = nullptr) : ApplicationContextImplBase&lt;QApplicationContext&gt;{parent}
    {
        finishConstruction();
    }

    virtual void doSomeFancyRegistration() override;
};
</pre><p>Should you really insist on implementing <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a> from scratch, here are some rules that you should follow:</p>
<ul>
<li>You can implement the <b>public</b> pure virtual functions simply by invoking them on the <em>delegate</em>.</li>
<li>The <b>protected</b> pure virtual functions can be implemented by using the corresponding static <code>delegate...()</code> functions from QApplicationContext. Pass in your <em>delegate</em> as the first argument, as shown below.</li>
<li>Be aware that the first StandardApplicationContext that you create as a <em>delegate</em> will automatically become the global instance. This is probably not what you want. Therefore, consider to unset the delegate explicitly, as shown in the code below!</li>
<li>Be aware that the <em>delegate</em> will be injected into all services as a parent automatically (unless they have an explicit parent). Also, the <em>init-methods</em> will receive the <em>delegate</em> as an argument, as will the QApplicationContextPostProcessor::process() method.<br  />
 In order to inject your own implementation instead, use the function <a class="el" href="qapplicationcontext_8h.html#adc186b91799443993261a9c701e1312f" title="Creates an ApplicationContext as a delegate for another context.  With the help of this function you ...">mcnepp::qtdi::newDelegate()</a> This is also shown below.</li>
<li>Do not forget to connect your instance to the signals emitted by the delegate. You may use the static function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a8d786fec477e3eaf0959a7ae6ff7188c" title="Connects the signals of a source-context with the corresponding signals of a target-context....">mcnepp::qtdi::QApplicationContext::delegateConnectSignals()</a>, as shown below.</li>
</ul>
<p>Here is an (incomplete) example of a custom implementation of <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a>: </p><pre class="fragment">class ExtendedApplicationContext : public mcnepp::qtdi::QApplicationContext {
  Q_OBJECT

  public:

    explicit ExtendedApplicationContext(QObject *parent) :
            QApplicationContext{parent},
            m_delegate{new newDelegate(this)}
    {
        unsetInstance(m_delegate); // Remove the delegate as global instance, should it have been set.
        if(setInstance(this)) { // Attempt to set this as global instance.
            qCInfo(loggingCategory()).noquote().nospace() &lt;&lt; "Installed " &lt;&lt; this &lt;&lt; " as global instance";
        } 
// Propagate signals from delegate to this:
        delegateConnectSignals(m_delegate, this);
    }


    ~ExtendedApplicationContext() {
        unsetInstance(this);
    }

    bool publish(bool allowPartial) override {
    // Implement a public pure virtual method by invoking on delegate:
        return m_delegate-&gt;publish(allowPartial);
    }

 // More public methods...

  protected:

    mcnepp::qtdi::service_registration_handle_t registerService(const QString &amp;name, const service_descriptor &amp;descriptor, const service_config&amp; config, ServiceScope scope, const QStringList&amp; profiles, QObject* baseObject) override {
    // Implement a protected pure virtual method by leveraging the corresponding static helper:
        return delegateRegisterService(m_delegate, name, descriptor, config, scope, profiles, baseObject);
    }

 // More protected methods...

  private:
    mcnepp::qtdi::QApplicationContext* const m_m_delegate;
};
</pre> </div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
