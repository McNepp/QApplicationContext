<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QApplicationContext: QApplicationContext</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QApplicationContext
   </div>
   <div id="projectbrief">A DI-Container for Qt-based applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">QApplicationContext </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__r_e_a_d_m_e"></a>A DI-Container for Qt-based applications, inspired by Spring</p>
<h1><a class="anchor" id="autotoc_md8"></a>
Motivation</h1>
<p>As an experienced developer, you know how crucial it is to follow the SOC (Separation Of Concern) - principle: <br  />
 Each component shall be responsible for "one task" only, (or, at least, for one set of related tasks). <br  />
 Things that are outside of a component's realm shall be delegated to other components. <br  />
 This, of course, means that some components will need to get references to those other components, commonly referred to as "Dependencies". <br  />
 Following this rule greatly increases testability of your components, thus making your software more robust.</p>
<p>But, sooner or later, you will ask yourself: How do I wire all those inter-dependent components together? <br  />
 How do I create application-wide "singletons" (without resorting to C++ singletions, which are notoriously brittle), and how can I create multiple implementations of the same interface?</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Features</h1>
<ul>
<li>Provides an easy-to use Container for Dependency-Injection of Qt-based components.</li>
<li>Offers a typesafe syntax for declaring dependencies between components in C++.</li>
<li>Automatically determines the precise order in which the inter-dependent components must be instantiated.</li>
<li>Helps make the components <em>container-agnostic</em>.</li>
<li>Dependency-injection via constructor.</li>
<li>Dependency-injection via Qt-properties.</li>
<li>Supports both one-to-one and one-to-many relations between components.</li>
<li>Further configuration of components after creation, including externalized configuration (using <code>QSettings</code>).</li>
<li>Automatic invocation of an <em>init-method</em> after creation, using Qt-slots.</li>
<li>Offers a Qt-signal for "published" components, together with a type-safe <code>subscribe()</code> mechanism.</li>
<li>Fail-fast, i.e. terminate compilation with meaningful diagnostics if possible.</li>
<li>Helps to find runtime-problems by generating verbose logging (using a <code>QLoggingCategory</code>).</li>
</ul>
<h1><a class="anchor" id="autotoc_md10"></a>
An example</h1>
<p>Suppose you have created a component named 'RestPropFetcher'. This component fetches a String-value from a Website, using http-GET and exposes this value as a Q_PROPERTY. Naturally, this component will make use of a <code>QNetworkAccessManager</code>. Also, a URL will be passed into the constructor. The declaration of such a component may look like this: </p><pre class="fragment">class RestPropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)


  public:

  RestPropFetcher(const QString&amp; url, QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  QString value() const;

  QString url() const;


  signals:
  void valueChanged();
};
</pre><p>Given the above component, the invocation of the constructor would look like this: </p><pre class="fragment">RestPropFetcher* fetcher = new RestPropFetcher{ QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, new QNetworkAccessManager}; 
</pre><p> When using a QApplicationContext, you can translate this constructor-call directly into an instantiation of <a class="el" href="structmcnepp_1_1qtdi_1_1_service.html" title="Describes a service by its interface and implementation. Compilation will fail if either Srv is not a...">mcnepp::qtdi::Service</a>.</p>
<p>We will soon see why this direct translation is usually not a good idea, but just for the record, this is what it looks like: </p><pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardApplicationContext; // 1

auto decl = service&lt;RestPropFetcher&gt;(QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, new QNetworkAccessManager}; // 2

context -&gt; registerService(decl, "hamburgWeather"); // 3

context -&gt; publish(); // 4
</pre><ol type="1">
<li>Creates a <code><a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext.">mcnepp::qtdi::StandardApplicationContext</a></code> on the heap. Note that we assign it to a pointer of the interface <code><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a></code>. This avoids accidental use of non-public API.</li>
<li>Creates a Declaration for the RestPropFetcher. The two arguments (the URL and the pointer to the <code>QNetworkAccessManager</code>) will be stored with the registration. They will be passed on to the constructor when the service is published.</li>
<li>Registers a RestPropFetcher with the context. The first argument is the name that this service shall have in the QApplicationContext.</li>
<li>The context is published. It will instantiate a RestPropFetcher and pass the two arguments to the constructor.</li>
</ol>
<p>The above code has an obvious flaw: The <code>QNetworkAccessManager</code> is created outside the QApplicationContext. It will not be managed by the Context. Should another service need a <code>QNetworkAccessManager</code>, you would have to create another instance.</p>
<p>We fix this by not providing the pointer to the <code>QNetworkAccessManager</code>, but instead using a kind of "placeholder" for it. This placeholder is the class-template <code><a class="el" href="structmcnepp_1_1qtdi_1_1_dependency.html" title="Specifies a dependency of a service.  Can by used as a type-argument for QApplicationContext::registe...">mcnepp::qtdi::Dependency</a></code>. We can create Dependencies by using one of the functions <a class="el" href="qapplicationcontext_8h.html#a52003170c4fd6d306dcc8a53eacd195e" title="Injects a mandatory Dependency.">mcnepp::qtdi::inject()</a>, <a class="el" href="qapplicationcontext_8h.html#a2ddf8a871e1f8982afcd787799816cc0" title="Injects an optional Dependency to another ServiceRegistration. This function will utilize the Registr...">mcnepp::qtdi::injectIfPresent()</a> or <a class="el" href="qapplicationcontext_8h.html#a52003170c4fd6d306dcc8a53eacd195e" title="Injects a mandatory Dependency.">mcnepp::qtdi::inject()</a>.</p>
<p>You can think of <code>inject</code> as a request to the QApplicationContext: <em>If a service of this type has been registered, please provide it here!</em>.</p>
<p>By leveraging <code>inject()</code>, our code becomes this:</p>
<pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardApplicationContext; // 1

context -&gt; registerService&lt;QNetworkAccessManager&gt;(); // 2
auto decl = service&lt;RestPropFetcher&gt;(QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}, inject&lt;QNetworkAccessManager&gt;()); // 3
context -&gt; registerService(decl, "hamburgWeather"); // 4

context -&gt; publish(); // 5
</pre><ol type="1">
<li>Creates a StandardApplicationContext on the heap.</li>
<li>Registers a QNetworkAccessManager with the context. We are supplying no explicit name here, so the component will get an auto-generated name! <b>Note:</b> This line uses the simplified overload of QApplicationContext::registerService() for Services with no dependencies.</li>
<li>Creates a Declaration for a RestPropFetcher. Again, we pass the first constructor-argument (the URL) directly. However, for the second argument, we use <code>inject&lt;QNetworkAccessManager&gt;()</code>.</li>
<li>Registers the descriptor with the context (as before).</li>
<li>The context is published. It will instantiate a QNetworkAccessManager first, then a RestPropFetcher, injecting the QNetworkAccessManager into its constructor.</li>
</ol>
<p><b>Note:</b> In the above example, we obtain the <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> for the <code>QNetworkAccessManager</code> in line 2.<br  />
 Whenever we want to express a dependency for a Service and we have the corresponding ServiceRegistration at hand, we can leave out the <code>inject()</code> and pass the ServiceRegistration directly as a dependency. <br  />
Thus, the lines 2 to 4 from our example could be simplified like this: </p><pre class="fragment">auto networkRegistration = context -&gt; registerService&lt;QNetworkAccessManager&gt;(); // 2
context -&gt; registerService(service&lt;RestPropFetcher&gt;(QString{"https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"), networkRegistration}, "hamburgWeather"); // 3
</pre><h1><a class="anchor" id="autotoc_md11"></a>
Parent-Child relation</h1>
<p>In the preceding example, the class <code>RestPropFetcher</code> was introduced which had the following constructor: </p><pre class="fragment">RestPropFetcher(const QString&amp; url, QNetworkAccessManager* networkManager, QObject* parent = nullptr);
</pre><p> This is typical for QObject-based services: the first arguments (aka the dependencies) are mandatory, while the last argument is an optional <code>parent</code>. <br  />
In the preceding example, the service was registered by supplying the first two arguments explicitly. Thus, no <code>parent</code> was supplied. <br  />
QApplicationContext will check for every service after creation whether the service already has a QObject::parent(). If not, <b>it will set itself as the service's parent</b> using QObject::setParent(QObject*). <br  />
However, what would you do if you had a constructor with a <em>mandatory parent</em>? <br  />
In that case, <a class="el" href="qapplicationcontext_8h.html#a2b4cd088db70b5b3179022c6e0b00fe2" title="Creates a placeholder for injecting the ApplicationContext into a service as the parent....">mcnepp::qtdi::injectParent()</a> comes to the rescue: </p><pre class="fragment">context-&gt;registerService(service&lt;RestPropFetcher&gt;(QString{"https://whatever"}, inject&lt;QNetworkAccessManager&gt;(), injectParent()));
</pre><p> This will cause the ApplicationContext to inject itself into the constructor as the parent.</p>
<h1><a class="anchor" id="externalized-configuration"></a>
Externalized Configuration</h1>
<p>In the above example, we were configuring the Url with a String-literal in the code. This is less than optimal, as we usually want to be able to change such configuration-values without re-compiling the program. <br  />
 This is made possible with so-called <em>placeholders</em> in the configured values: <br  />
 When passed to the function <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>, a placeholder embedded in <code>${ }</code> will be resolved by the QApplicationContext using Qt's <code>QSettings</code> class. <br  />
 You simply register one or more instances of <code>QSettings</code> with the context, using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a8bf49def9048cc92c5aa5d1a9437682f" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>.</p>
<h2><a class="anchor" id="constructor-arguments"></a>
Using Constructor-arguments</h2>
<p>This is what it looks like if you out-source the "url" configuration-value into an external configuration-file: </p><pre class="fragment">context -&gt; registerObject(new QSettings{"application.ini", QSettings::IniFormat, context});

context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${hamburgWeatherUrl}"), inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather"); 
context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${berlinWeatherUrl}"), inject&lt;QNetworkAccessManager&gt;()), "berlinWeather"); 
</pre><p>You could even improve on this by re-factoring the common part of the Url into its own configuration-value: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${hamburgStationId}"), inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather"); 
context -&gt; registerService(service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${berlinStationId}"), inject&lt;QNetworkAccessManager&gt;()), "berlinWeather"); 
</pre> <h2><a class="anchor" id="autotoc_md12"></a>
Order of lookup</h2>
<p>Whenever a <em>placeholder</em> shall be looked up, the ApplicationContext will search the following sources, until it can resolve the <em>placeholder</em>:</p>
<ol type="1">
<li>The environment, for a variable corresponding to the <em>placeholder</em>.</li>
<li>The instances of <code>QSettings</code> that have been registered in the ApplicationContext.</li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
Configuring values of non-String types</h2>
<p>With <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>, you can also process arguments of types other than <code>QString</code>. You just need to specify the template-argument explicitly, or pass a default-value to be used when the expression cannot be resolved.</p>
<p>Let's say there was an argument of type <code>int</code> that specified the connection-timeout in milliseconds. Then, the service-declaration would be: </p><pre class="fragment">auto decl = service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${hamburgStationId}"), resolve&lt;int&gt;("${connectionTimeout}"), inject&lt;QNetworkAccessManager&gt;());
</pre><p> You will notice the explicit type-argument used on <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a>. Needless to say, the configured value for the key "connectionTimeout" must resolve to a valid integer-literal!</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Specifying default values</h2>
<p>Sometimes, you may want to provide a constructor-argument that can be externally configured, but you are unsure whether the configuration will always be present at runtime.</p>
<p>There are two ways of doing this:</p>
<ol type="1">
<li>You can supply a default-value to the function-template <a class="el" href="qapplicationcontext_8h.html#a59d0392bb960299590af56049c779ba8" title="Specifies a constructor-argument that shall be resolved by the QApplicationContext....">mcnepp::qtdi::resolve()</a> as its second argument: <code>resolve("${connectionTimeout}", 5000)</code>. This works only for constructor-arguments (see <a class="el" href="index.html#constructor-arguments">Using Constructor-arguments</a>).</li>
<li>You can put a default-value into the placeholder-expression, separated from the placeholder by a colon: <code>"${connectionTimeout:5000}"</code>. Such an embedded default-value takes precedence over one supplied to mqnepp::qtdi::resolve(). This works for both constructor-arguments and Q_PROPERTYs (see <a class="el" href="index.html#configuring-services">Configuring services with Q_PROPERTY</a>).</li>
</ol>
<h2><a class="anchor" id="autotoc_md15"></a>
Specifying an explicit Group</h2>
<p>If you structure your configuration in a hierarchical manner, you may find it useful to put your configuration-values into a <code>QSettings::group()</code>. Such a group can be specified for your resolvable values by means of the <a class="el" href="qapplicationcontext_8h.html#a5b2c15ddf8bc9c211e489ad7daea3666">mcnepp::qtdi::config()</a> function. In the following example, the configuration-keys "baseUrl", "hamburgStationId" and "connectionTimeout" are assumed to reside in the group named "mcnepp": </p><pre class="fragment">auto decl = service&lt;RestPropFetcher&gt;(resolve("${baseUrl}?stationIds=${hamburgStationId}"), resolve&lt;int&gt;("${connectionTimeout}"), inject&lt;QNetworkAccessManager&gt;());
appContext -&gt; registerService(decl, "hamburgWeather", config().withGroup("mcnepp"));
</pre> <h2><a class="anchor" id="autotoc_md16"></a>
Lookup in sub-sections</h2>
<p>Every key will be looked up in the section that has been provided via as an argument to <a class="el" href="qapplicationcontext_8h.html#a5b2c15ddf8bc9c211e489ad7daea3666">mcnepp::qtdi::config()</a>, argument, unless the key itself starts with a forward slash, which denotes the root-section.</p>
<p>A special syntax is available for forcing a key to be looked up in parent-sections if it cannot be resolved in the provided section: Insert <code>*/</code> right after the opening sequence of the placeholder. </p><pre class="fragment">context -&gt; registerService(service&lt;QIODevice,QFile&gt;(resolve("${*/filename}")), "file", config().withGroup("files"));
</pre><p> The key "filename" will first be searched in the section "files". If it cannot be found, it will be searched in the root-section.</p>
<h1><a class="anchor" id="configuring-services"></a>
Configuring services with Q_PROPERTY</h1>
<p>We have seen how we can inject configuration-values into Service-constructors. Another way of configuring Services is to use Q_PROPERTY declarations. Suppose we modify the declaration of <code>RestPropFetcher</code> like this: </p><pre class="fragment">class RestPropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(QString url READ url WRITE setUrl NOTIFY urlChanged)

  Q_PROPERTY(int connectionTimeout READ connectionTimeout WRITE setConnectionTimeout NOTIFY connectionTimeoutChanged)


  public:

  explicit RestPropFetcher(QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  QString value() const;

  QString url() const;

  void setUrl(const QString&amp;);

  void setConnectionTimeout(int);

  int connectionTimeout() const;

  signals:

  void valueChanged();
  void urlChanged();
  void connectionTimeoutChanged();
};
</pre><p>Now, the "url" cannot be injected into the constructor. Rather, it must be set explicitly via the corresponding Q_PROPERTY. For this, the yet unused <code>service_config</code> argument comes into play: It contains a <code>QVariantMap</code> with the names and values of properties to set: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather", config({{"url", "${baseUrl}?stationIds=${hamburgStationId}"}, {"connectionTimeout", "${connectionTimeout:5000}}));
context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()), "berlinWeather", config({{"url", "${baseUrl}?stationIds=${berlinStationId}"}, {"connectionTimeout", "${connectionTimeout:5000}})); 
</pre><p> As you can see, the code has changed quite significantly: instead of supplying the Url as a constructor-argument, you use <a class="el" href="qapplicationcontext_8h.html#a5b2c15ddf8bc9c211e489ad7daea3666">mcnepp::qtdi::config()</a> and pass in the key/value-pairs for configuring the service's url and connectionTimeouts as Q_PROPERTYs.</p>
<p><b>Note:</b> Every property supplied to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> will be considered a potential Q_PROPERTY of the target-service. <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> will fail if no such property can be found. <br  />
 However, if you prefix the property-key with a dot, it will be considered a <em>private property</em>. It will still be resolved via QSettings, but no attempt will be made to access a matching Q_PROPERTY. Such <em>private properties</em> may be passed to a <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(servic...">mcnepp::qtdi::QApplicationContextPostProcessor</a> (see section <a class="el" href="index.html#tweaking-services">Tweaking services</a> below).</p>
<p>Alsol, <em>priavte properties</em> can be very useful in conjunction with <a class="el" href="index.html#service-templates">Service-templates</a>.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Service-prototypes</h1>
<p>As shown above, a service that was registered using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> will be instantiated once <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a> is invoked. <br  />
A single instance of the service will be injected into every other service that depends on it.</p>
<p>However, there may be some services that cannot be shared between dependent services. In this case, use <a class="el" href="qapplicationcontext_8h.html#a2438ec3e3e81944f1c8c8eeee580998d" title="Creates a Service-prototype with the default service-factory.">mcnepp::qtdi::prototype()</a> instead of <a class="el" href="qapplicationcontext_8h.html#a07ae03c57a4c371f2f24659088813670" title="Creates a Service with the default service-factory.">mcnepp::qtdi::service()</a> as an argument to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>. <br  />
Such a registration will not necessarily instantiate the service on <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a>. Only if there are other services depending on it will a new instance be created and injected into the dependent service.</p>
<p>Every instance of a service-protoype that gets injected into a dependent service will be made a QObject-child of the dependent service. In other words, the dependent service becomes the <em>owner</em> of the prototype-instance.</p>
<p>The same is true for <em>references to other members</em>: if a protoype is referenced via the ampersand-syntax, the instance of that prototype will be made a child of the service that references it.</p>
<h1><a class="anchor" id="service-templates"></a>
Service-templates</h1>
<p>A service-template is a recipe for configuring a service without actually registering a concrete service. Such a template can then be re-used when further concrete services are registered. <br  />
(For those familiar with Spring-DI: this would be an *"abstract"* bean-definition). <br  />
A Service-template can be registered like this: </p><pre class="fragment">auto restFetcherTemplateRegistration = context -&gt; registerService(serviceTemplate&lt;RestPropFetcher&gt;(), "fetcherBase", config({
    {"connectionTimeout", "${connectionTimeout:5000}
    {"url", "${baseUrl}?stationIds=${stationId}"}
}));
</pre><p> <br  />
The return-value has the type <code>ServiceRegistration&lt;RestPropFetcher,ServiceScope::TEMPLATE&gt;</code>. It can be supplied as an additional argument to subsequent registrations: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(), restFetcherTemplateRegistration, "hamburgWeather", config({{".stationId", "10147"}});
</pre><p> If a service-registration utilizes a service-template, the type of the registered service must be implicitly convertible to the service-template's type. In particular, it can be the same type (as can be seen in the example above).</p>
<p>Service-templates have the following capabilities:</p>
<ol type="1">
<li>Uniform configuration. You may configure Q_PROPERTYs in a uniform way for all services that use this template. See the property <code>connectionTimeout</code> in the above example, which will be set to the same value for every service derived from this template. Even more interesting is the use of the placeholder <code>${stationId}</code> in the template's configuration. It will be resolved by use of a <em>private property</em> at the registration of the concrete service.</li>
<li>Init-Methods. You may specify an <em>init-method</em> via the <code><a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a></code> of the service-template.</li>
<li>Uniform advertising of service-interfaces. You may once specify the set of interfaces that a service-template advertises. That way, you don't need to repeat this for every service that uses the template. (See section <a class="el" href="index.html#service-interfaces">Service-interfaces</a> below).</li>
</ol>
<h2><a class="anchor" id="autotoc_md18"></a>
Generic (un-validated) properties of Service-templates</h2>
<p>Registration of a service-template differs from the registration of a "normal" service in one important aspect:</p>
<p>The properties that you provide via <a class="el" href="qapplicationcontext_8h.html#a5b2c15ddf8bc9c211e489ad7daea3666">mcnepp::qtdi::config()</a> will not be validated against the Q_PROPERTYs of the service's implementation-type!</p>
<p>The rationale is that the service-template may be used by services of yet unknown type. The validation of a Q_PROPERTY will therefore be postponed until registration of the concrete service that derives from this service-template.</p>
<p>This makes it possible to register configured service-templates without assuming any particular service-type at all! <br  />
In order to facilitate this, the type-argument of the function <a class="el" href="qapplicationcontext_8h.html#a1dc51a0152614fb643aaf888bf901eae" title="Creates a Service-template with no dependencies and no constructor.  The returned Service cannot be i...">mcnepp::qtdi::serviceTemplate()</a> has a default-type of <code>QObject</code>.</p>
<p>Using this knowledge, let's register a service-template for arbitrary services that support a Q_PROPERTY <code>url</code>:</p>
<pre class="fragment">auto urlAware = context-&gt;registerService(serviceTemplate(), "urlAware", config({{ "url", "http://github.com"}}));
</pre><p> This can be expressed even more concisely using the convenience-function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#afba617274aeee33b363468030d9064c5" title="Registers a service-template with no dependencies with this ApplicationContext. This is a convenience...">mcnepp::qtdi::QApplicationContext::registerServiceTemplate()</a>: </p><pre class="fragment">auto urlAware = context-&gt;registerServiceTemplate("urlAware", config({{ "url", "http://github.com"}}));
</pre><h1><a class="anchor" id="autotoc_md19"></a>
Managed Services vs. Un-managed Objects</h1>
<p>The function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> that was shown in the preceeding example results in the creation of a <code>managed service</code>. <br  />
 The entire lifecylce of the registered Service will be managed by the QApplicationContext. <br  />
 Sometimes, however, it will be necessary to register an existing QObject with the ApplicationContext and make it available to other components as a dependency. <br  />
 A reason for this may be that the constructor of the class does not merely accept other <code>QObject</code>-pointers (as "dependencies"), but also <code>QString</code>s or other non-QObject-typed value. <br  />
 A good example would be registering objects of type <code>QSettings</code>, which play an important role in <a class="el" href="index.html#externalized-configuration">Externalized Configuration</a>. <br  />
</p>
<p>There are some crucial differences between <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>, when invoked with either <a class="el" href="qapplicationcontext_8h.html#a07ae03c57a4c371f2f24659088813670" title="Creates a Service with the default service-factory.">mcnepp::qtdi::service()</a> or <a class="el" href="qapplicationcontext_8h.html#a2438ec3e3e81944f1c8c8eeee580998d" title="Creates a Service-prototype with the default service-factory.">mcnepp::qtdi::prototype()</a>. Also, there are differences to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a8bf49def9048cc92c5aa5d1a9437682f" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>, as the following table shows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">registerService(service())   </th><th class="markdownTableHeadNone">registerService(prototype())   </th><th class="markdownTableHeadNone">registerObject    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Instantiation of the object   </td><td class="markdownTableBodyNone">Upon <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>   </td><td class="markdownTableBodyNone">In <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>,<br  />
but only if another service requests it   </td><td class="markdownTableBodyNone">Prior to the registration with the QApplicationContext    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">When is the signal <code>objectPublished(QObject*)</code> emitted?   </td><td class="markdownTableBodyNone">Upon <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>   </td><td class="markdownTableBodyNone">In <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a>,<br  />
but only if another service requests it   </td><td class="markdownTableBodyNone">Immediately after the registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Naming of the QObject   </td><td class="markdownTableBodyNone" colspan="2"><code>QObject::objectName</code> is set to the name of the registration   </td><td class="markdownTableBodyNone"><code>QObject::objectName</code> is not touched by QApplicationContext    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Handling of Properties   </td><td class="markdownTableBodyNone" colspan="2">The key/value-pairs supplied at registration will be set as Q_PROPERTYs by QApplicationContext   </td><td class="markdownTableBodyNone">All properties must be set before registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Processing by <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(servic...">mcnepp::qtdi::QApplicationContextPostProcessor</a>   </td><td class="markdownTableBodyNone" colspan="2">Every service will be processed by the registered QApplicationContextPostProcessors   </td><td class="markdownTableBodyNone">Object is not processed    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Invocation of <em>init-method</em>   </td><td class="markdownTableBodyNone" colspan="2">If present, will be invoked by QApplicationContext   </td><td class="markdownTableBodyNone">If present, must have been invoked prior to registration    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Parent/Child-relation   </td><td class="markdownTableBodyNone">If a Service has no parent after its <em>init-method</em> has run, the ApplicationContext will become the service's parent.   </td><td class="markdownTableBodyNone">The instance of the prototype will be made a child of the service that required it.   </td><td class="markdownTableBodyNone">The parent of the Object will not be touched.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Destruction of the object   </td><td class="markdownTableBodyNone">Upon destruction of the QApplicationContext   </td><td class="markdownTableBodyNone">Upon destruction of the Service that owns the prototype-instance.   </td><td class="markdownTableBodyNone">At the discrection of the code that created it   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md20"></a>
Types of dependency-relations</h1>
<p>In our previous example, we have seen the dependency of our <code>RestPropFetcher</code> to a <code>QNetworkAccessManager</code>. <br  />
 This constitutes a <em>mandatory dependency</em>: instantion of the <code>RestPropFetcher</code>will fail if no <code>QNetworkAccessManager</code>can be found. However, there are more ways to express a dependency-relation. <br  />
 This is reflected by the enum-type <code><a class="el" href="qapplicationcontext_8h.html#aa26d711edb47348796326730adbbc521" title="Specifies the kind of a service-dependency. Will be used as a non-type argument to Dependency,...">mcnepp::qtdi::Kind</a></code> and its enum-constants as listed below:</p>
<h2><a class="anchor" id="autotoc_md21"></a>
MANDATORY</h2>
<p>As stated before, mandatory dependencies enforce that there is exactly one service of the dependency-type present in the ApplicationContext. Otherwise, publication will fail. Mandatory dependencies can be specified by using inject(): </p><pre class="fragment">context-&gt;registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()));
</pre><p> In case you have the ServiceRegistration for the dependency at hand, you may skip the invocation of <a class="el" href="qapplicationcontext_8h.html#a52003170c4fd6d306dcc8a53eacd195e" title="Injects a mandatory Dependency.">mcnepp::qtdi::inject()</a> and use the ServiceRegistration directly:</p>
<p>....auto networkRegistration = context-&gt;registerService&lt;QNetworkAccessManager&gt;(); context-&gt;registerService(service&lt;RestPropFetcher&gt;(networkRegistration));</p>
<h2><a class="anchor" id="autotoc_md22"></a>
OPTIONAL</h2>
<p>A service that has an <em>optional dependency</em> to another service may be instantiated even when no matching other service can be found in the ApplicationContext. In that case, <code>nullptr</code> will be passed to the service's constructor. <br  />
 Optional dependencies are specified the <code>Dependency</code> helper-template. Suppose it were possible to create our <code>RestPropFetcher</code> without a <code>QNetworkAccessManage</code>: </p><pre class="fragment">context-&gt;registerService(service&lt;RestPropFetcher&gt;(injectIfPresent&lt;QNetworkAccessManager&gt;()));
</pre> <h2><a class="anchor" id="autotoc_md23"></a>
N (one-to-many)</h2>
<p>Now, let's extend our example a bit: we want to create a component that shall receive the fetched values from all RestPropFetchers and somehow sum them up. Such a component could look like this: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;RestPropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> Note that the above component comprises a one-to-,any relationship with its dependent components. We must notify the QApplicationContext about this, so that it can correctly inject all the matching dependencies into the component's constructor. <br  />
 The following statement will do the trick: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;RestPropFetcher&gt;()), "propFetcherAggregation");
</pre><p> <b>Note:</b>, while constructing the <code>QList</code> with dependencies, the ordering of registrations of <b>non-interdependent services</b> will be honoured as much as possible. In the above example, the services "hamburgWeather" and "berlinWeather" will appear in that order in the <code>QList</code> that is passed to the <code>PropFetcherAggreator</code>.</p>
<p>In case you have the ProxyRegistration for the dependency at hand, you may skip the invocation of <a class="el" href="qapplicationcontext_8h.html#a52003170c4fd6d306dcc8a53eacd195e" title="Injects a mandatory Dependency.">mcnepp::qtdi::inject()</a> and use the ProxyRegistration directly:</p>
<p>....auto networkRegistration = context-&gt;getRegistration&lt;QNetworkAccessManager&gt;(); context-&gt;registerService(service&lt;PropFetcherAggregator&gt;(networkRegistration));</p>
<p>The following table sums up the characteristics of the different types of dependencies:</p>
<table class="doxtable">
<tr>
<th>&#160;</th><th>Normal behaviour</th><th>What if no dependency can be found?</th><th>What if more than one dependency can be found? </th></tr>
<tr>
<td>MANDATORY</td><td>Injects one dependency into the dependent service.</td><td>Publication of the ApplicationContext will fail. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
<tr>
<td>OPTIONAL</td><td>Injects one dependency into the dependent service</td><td>Injects <code>nullptr</code> into the dependent service. </td><td>Publication will fail with a diagnostic, unless a <code>requiredName</code> has been specified for that dependency. </td></tr>
<tr>
<td>N</td><td>Injects all dependencies of the dependency-type that have been registered into the dependent service, using a <code>QList</code> </td><td>Injects an empty <code>QList</code> into the dependent service. </td><td>See 'Normal behaviour' </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md24"></a>
Converting Dependencies</h1>
<p>As we have seen in the previous section, a mandatory Dependency of type T will be injected into the dependent Service's constructor as a <code>T*</code>. <br  />
Likewise, a one-to-many Dependency of type T will be injected into the dependent Service's constructor as a <code>QList&lt;T*&gt;</code>. <br  />
However, sometimes a Service may have a constructor that accepts its dependencies in a different format. Suppose that the class <code>PropFetcherAggregator</code> were declared like this: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  static constexpr MAX_FETCHERS = 10;

  explicit PropFetcherAggregator(const std::array&lt;RestPropFetcher*,MAX_FETCHERS&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> There is no implicit conversion from a QList to <code>a std::array</code>. Thus, we'd have to write a converter that accepts a <code>QObjectList</code> and produces a <code>std::array</code>. Actually, the converter's argument-type must be <code>QVariant</code>, as that will be passed by the ApplicationContext.</p>
<pre class="fragment">struct propfetcher_set_converter {
  using array_t = std::array&lt;RestPropFetcher*,PropFetcherAggregator::MAX_FETCHERS&gt;;

  array_t operator()(const QVariant&amp; arg) const {
    array_t target;
    auto qlist = arg.value&lt;QObjectList&gt;();
    std::copy_n(qlist.begin(), std::min(target.size(), qlist.size()), target.begin());
    return target;        
  }
};
</pre><p> Now when we register the <code>PropFetcherAggregator</code> with an ApplicationContext, we simply specify this converter as a type-argument: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;RestPropFetcher,propfetcher_set_converter&gt;()));
</pre> <h1><a class="anchor" id="service-interfaces"></a>
Service-interfaces</h1>
<p>In the preceeding example, we have registered our QObject-derived class <code>RestPropFetcher</code> directly, using the function template <a class="el" href="qapplicationcontext_8h.html#a07ae03c57a4c371f2f24659088813670" title="Creates a Service with the default service-factory.">mcnepp::qtdi::service()</a> with one type-argument (aka <code>"service&lt;RestPropFetcher&gt;()"</code>).<br  />
 Such a registration will register the implementation-type <code>RestPropFetcher</code> with the same service-interface. <br  />
We have also specified the class as the dependency-type for <code>PropFetcherAggregator</code>. <br  />
 However, in most complex applications you will likely use an abstract base-class (or 'interface'). Additionally, this interface need not be derived from QObject! <br  />
 This is well supported by QApplicationContext. First, let's declare our interface: </p><pre class="fragment">class PropFetcher  {

  public:

  virtual QString value() const = 0;

  virtual ~PropFetcher() = default;
};
</pre><p> Then, we modify our class <code>RestPropFetcher</code> so that it derives from both QObject and this interface: </p><pre class="fragment">class RestPropFetcher : public QObject, public PropFetcher {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(QString url READ url WRITE setURl NOTIFY urlChanged)

  public:

  explicit RestPropFetcher(QNetworkAccessManager* networkManager, QObject* parent = nullptr);

  virtual QString value() const override;

  QString url() const;

  void setUrl(const QString&amp;);

  signals:

  void valueChanged();

  void urlChanged();
};
</pre><p> Having done this, we will now register the <code>RestPropFetcher</code> with the <em>service-interface</em> <code>PropFetcher</code>: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()));
</pre><p> As you can see, there are now two type-arguments: the first one being the service-interface, the second being the implementation-type.</p>
<p>What would you do if you wanted to advertise the service with more than one service-interface? Well, you use the form with one type-argument again, but then have it followed by a call to <code>advertiseAs()</code>, which accepts an arbitrary number of interface-types!</p>
<p>Here's what that would look like: </p><pre class="fragment">context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher&gt;());
</pre><p> In order to make use of our interface, we modify our class <code>PropFetcherAggregator</code> so that it accepts dependencies of the interface-type: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> Putting it all together, we use the helper-template <code>Service</code> for specifying both an interface-type and an implementation-type:</p>
<pre class="fragment">using namespace mcnepp::qtdi;

QApplicationContext* context = new StandardQApplicationContext; 

context -&gt; registerService&lt;QNetworkAccessManager&gt;();

context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAllOf&lt;PropFetcher&gt;()), "propFetcherAggration");

/*2*/ context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher&gt;(), "hamburgWeather", config({{"url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}})); 

context -&gt; publish(); 
</pre><p> <b>Note:</b> The order of registrations has been switched: now, the dependent service <code>PropFetcherAggregator</code> is registered before the services it depends on. This was done to demonstrate that, <b>regardless of the ordering of registrations</b>, the dependencies will be resolved correctly! Also, there are two type-arguments for the Service now: the first specifies the type of service-interface, the second the implementation-type.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Multiple service-interfaces</h2>
<p>A service may be advertised under more than one service-interface. This makes sense if the service-type implements several non-QObject interfaces that other services depend on. Suppose the class <code>RestPropFetcher</code> implements an additional interface <code>QNetworkManagerAware</code>: </p><pre class="fragment">class QNetworkManagerAware {
   virtual ~QNetworkManagerAware() = default;

   virtual setNetworkManager(QNetworkAccessManager*) = 0;
};

class PropFetcher : public QObject, public QNetworkManagerAware {

explicit PropFetcher(const QString&amp; url, QObject* parent = nulptr);

virtual setNetworkManager(QNetworkAccessManager*) override;
...//same as before
};

class RestPropFetcher : public PropFetcher, public QNetworkManagerAware {
...
};
</pre><p> In order to advertise a <code>RestPropFetcher</code> as both a <code>PropFetcher</code> and a <code>QNetworkManagerAware</code>, we use: </p><pre class="fragment">auto reg = context -&gt; registerService(service&lt;RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()).advertiseAs&lt;PropFetcher,QNetworkManagerAware&gt;(), "hamburgWeather", config({{"url", "https://dwd.api.proxy.bund.dev/v30/stationOverviewExtended?stationIds=10147"}})); 
</pre><p> <b>Note:</b> The return-value <code>reg</code> will be of type <code>ServiceRegistration&lt;RestPropFetcher,ServiceScope::SINGLETON&gt;</code>.</p>
<p>You may convert this value to <code>ServiceRegistraton&lt;PropFetcher,ServiceScope::SINGLETON&gt;</code> as well as <code>ServiceRegistration&lt;QNetworkManagerAware,ServiceScope::SINGLETON&gt;</code>, using the member-function ServiceRegistration::as(). Conversions to other types will not succeed.</p>
<h1><a class="anchor" id="autotoc_md26"></a>
Referencing other members of the ApplicationContext</h1>
<p>Sometimes, it may be necessary to inject one member of the ApplicationContext into another member not via constructor, but via a Q_PROPERTY. <br  />
 Suppose that each <code>PropFetcher</code> shall have (for whatever reason) a reference to the <code>PropFetcherAggregator</code>. <br  />
 This cannot be done via constructor-arguments, as it would constitute a dependency-circle! <br  />
 However, we could introduce a Q_PROPERTY like this: </p><pre class="fragment">class PropFetcher : public QObject {
  Q_OBJECT

  Q_PROPERTY(QString value READ value NOTIFY valueChanged)

  Q_PROPERTY(PropFetcherAggregator* summary READ summary WRITE setSummary NOTIFY summaryChanged)

  public:

  explicit PropFetcher(QObject* parent = nullptr);

  virtual QString value() const = 0;

  virtual PropFetcherAggregator* summary() const = 0;

  virtual void setSummary(PropFetcherAggregator*) = 0;

  signals:
  void valueChanged();

  void summaryChanged();
};
</pre><p> And here's how this property will be automatically set to the ApplicationContext's <code>PropFetcherAggregator</code>. Note the ampersand as the first character of the property-value, which makes this a <em>reference to another member</em>:</p>
<pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;()), "propFetcherAggregator");

context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher(inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather", config({
  {"url", "${weatherUrl}${hamburgStationId}"},
  {"summary", "&amp;propFetcherAggregator"}
}));
</pre><p>In the preceeding example, we used a reference to another member to initialize a.</p>
<p>We can take this one step further and use <em>a reference to a property of another member</em>. This can be achieved by using a property-value with the format <code>"&amp;ref.prop"</code>. The following example shows this: </p><pre class="fragment">QTimer timer1;

auto reg1 = context -&gt; registerObject(&amp;timer1, "timer1"); // 1

auto reg2 = context -&gt; registerService&lt;QTimer&gt;("timer2", config({{"interval", "&amp;timer1.interval"}})); // 2

context -&gt; publish(); 
</pre><ol type="1">
<li>We register a <code>QTimer</code> as "timer1".</li>
<li>We register a second <code>QTimer</code> as "timer2". We use <a class="el" href="qapplicationcontext_8h.html#a5b2c15ddf8bc9c211e489ad7daea3666">mcnepp::qtdi::config()</a> to initialize the property <code>interval</code> of the second timer with the first timer's propery.</li>
</ol>
<h1><a class="anchor" id="autotoc_md27"></a>
Binding source-properties to target-properties of other members of the ApplicationContext</h1>
<p>In the preceeding example, we used a reference to another member for the purpose of <b>initializing</b> a Q_PROPERTY.</p>
<p>However, we might also want to <b>bind</b> a target-service's property to the corresponding source-property of another service.</p>
<p>This can be achieved using the function <a class="el" href="qapplicationcontext_8h.html#a0f11a14df333d20850559efeee464e15" title="Binds a property of one ServiceRegistration to a property from another Registration....">mcnepp::qtdi::bind()</a> like this: </p><pre class="fragment">QTimer timer1;

auto reg1 = context -&gt; registerObject(&amp;timer1, "timer1"); // 1

auto reg2 = context -&gt; registerService&lt;QTimer&gt;("timer2"); // 2

bind(reg1, "interval", reg2, "interval"); // 3

context -&gt; publish(); 

timer1.setInterval(4711); // 4
</pre><ol type="1">
<li>We register a <code>QTimer</code> as "timer1".</li>
<li>We register a second <code>QTimer</code> as "timer2".</li>
<li>We bind the property <code>interval</code> of the second timer to the first timer's propery.</li>
<li>We change the first timer's interval. This will also change the second timer's interval!</li>
</ol>
<p>This way of binding properties has the advantage that it can also be applied to ServiceRegistrations obtained via QApplicationContext::getRegistration(), aka those that represent more than one service. The source-property will be bound to every target-service automatically!</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Type-safe bindings</h2>
<p>The above binding used property-names to denote the source- and target-properties. <br  />
In case the source-service offers a signal that corresponds with the property, you can use pointers to member-functions instead, which is more type-safe. <br  />
Here is an example: </p><pre class="fragment">QTimer timer1;

auto reg1 = context -&gt; registerObject(&amp;timer1, "timer1"); // 1

auto reg2 = context -&gt; registerService&lt;QTimer&gt;("timer2"); // 2

bind(reg1, &amp;QTimer::objectNameChanged, reg2, &amp;QTimer::setObjectName); // 3

context -&gt; publish(); 

timer1.setObjectName("new Name"); // 4
</pre><ol type="1">
<li>We register a <code>QTimer</code> as "timer1".</li>
<li>We register a second <code>QTimer</code> as "timer2".</li>
<li>We bind the property <code>objectName</code> of the second timer to the first timer's propery.</li>
<li>We change the first timer's objectName. This will also change the second timer's objectName!</li>
</ol>
<h1><a class="anchor" id="autotoc_md29"></a>
Accessing a service after registration</h1>
<p>So far, we have published the ApplicationContext and let it take care of wiring all the components together. <br  />
 In some cases, you need to obtain a reference to a member of the Context after it has been published. <br  />
 This is where the return-value of <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> comes into play: <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a>.</p>
<p>It offers the method <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#aa70f34088d747d139cf12f9e7e02df8f" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a>, which is a type-safe version of a Qt-Signal. (It is actually implemented in terms of the Signal mcnepp::qtdi::Registration::objectPublished(QObject*)).</p>
<p>In addition to being type-safe, the method <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#aa70f34088d747d139cf12f9e7e02df8f" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a> has the advantage that it will automatically inject the service if you subscribe after the service has already been published. <br  />
 This code shows how to utilize it: </p><pre class="fragment">auto registration = context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather", config({{"url", "${weatherUrl}${hamburgStationId}"}})); 

registration.subscribe(this, [](PropFetcher* fetcher) { qInfo() &lt;&lt; "I got the PropFetcher!"; });
</pre><p> The function <a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#aa70f34088d747d139cf12f9e7e02df8f" title="Receive all published QObjects in a type-safe way. Connects to the publishedObjectsChanged signal and...">mcnepp::qtdi::ServiceRegistration::subscribe()</a> does return a value of type <a class="el" href="classmcnepp_1_1qtdi_1_1_subscription.html" title="An opaque handle to a detail::Subscription. Instances of this class will be returned by Registration:...">mcnepp::qtdi::Subscription</a>. Usually, you may ignore this return-value. However, it can be used for error-checking and for cancelling a subscription, should that be necessary.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Accessing published services of the ApplicationContext</h1>
<p>In the previous paragraph, we used the <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> obtained by <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>, which refers to a single member of the ApplicationContext. However, we might be interested in all services of a certain service-type. <br  />
 This can be achieved using <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#aafdabdace508bc72e8145ae328d46a11" title="Obtains a ServiceRegistration for a service-type and name.  This function will look up Services by th...">mcnepp::qtdi::QApplicationContext::getRegistration()</a>, which yields a <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> that represents <em>all services of the requested service-type</em>.</p>
<pre class="fragment">auto registration = context -&gt; getRegistration&lt;PropFetcher&gt;();
qInfo() &lt;&lt; "There have been" &lt;&lt; registration.maxPublications() &lt;&lt; "RestPropFetchers so far!";    
</pre><p> You may also access a specific service by name: </p><pre class="fragment">auto registration = context -&gt; getRegistration&lt;PropFetcher&gt;("hamburgWeather");
if(!registration) {
 qWarning() &lt;&lt; "Could not obtain service 'hamburgWeather'";
}
</pre><h1><a class="anchor" id="tweaking-services"></a>
Tweaking services (QApplicationContextPostProcessor)</h1>
<p>Whenever a service has been instantiated and all properties have been set, QApplicationContext will apply all registered <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context_post_processor.html" title="A mix-in interface for classes that may modify services before publication. The method process(servic...">mcnepp::qtdi::QApplicationContextPostProcessor</a>`s to it. These are user-supplied QObjects that implement the aforementioned interface which comprises a single method: </p><pre class="fragment">QApplicationContextPostProcessor::process(service_registration_handle_t, QObject*,const QVariantMap&amp;)
</pre><p> In this method, you might apply further configuration to your service there, or perform logging or monitoring tasks.<br  />
 Any information that you might want to pass to a QApplicationContextPostProcessor can be supplied as so-called <em>private properties</em> via <a class="el" href="qapplicationcontext_8h.html#a5b2c15ddf8bc9c211e489ad7daea3666">mcnepp::qtdi::config()</a>. Just prefix the property-key with a dot.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Service-Initializers</h1>
<p>The last step done in <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish()</a> for each service is the invocation of an <em>init-method</em>, should one have been specified.</p>
<p>The same <em>init-method</em> should be used for every service of a certain type. In order to achieve this, you need to specialize <a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a> for your service-type and declare a type-alias named <code>initializer_type</code>.</p>
<p>A suitable type would be a callable <code>struct</code> with either one argument of the service-type, or with two arguments, the second being of type <code>QApplicationContext*</code>. </p><pre class="fragment">struct RestPropFetcher_initializer{
  void operator()(PropFetcherAggregator* service) const {
     service -&gt; init();
  }
};

namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;RestPropFetcher&gt; : default_service_traits&lt;RestPropFetcher&gt; {
     using initializer_type = RestPropFetcher_initializer;
  };
}
</pre><h2><a class="anchor" id="autotoc_md32"></a>
Initialization by function-reference</h2>
<p>In the above example, the callable <code>struct RestPropFetcher_initializer</code> simply invokes the method <code>PropFetcherAggregator::init()</code>. Shouldn't we be able to get rid of the <code>struct RestPropFetcher_initializer</code> somehow? <br  />
This is indeed possible. The helper-type <a class="el" href="structmcnepp_1_1qtdi_1_1service__initializer.html" title="A helper-template that converts a pointer to a function or a pointer to a member-function into a dist...">mcnepp::qtdi::service_initializer</a> takes a pointer to a member-function and converts it into a type. That way, we can reference the member-function (almost) directly in our service_traits: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;RestPropFetcher&gt; : default_service_traits&lt;RestPropFetcher&gt; {
     using initializer_type = service_initializer&lt;&amp;RestPropFetcher::init&gt;;
  };
}
</pre><h2><a class="anchor" id="autotoc_md33"></a>
Specifying initializers via interfaces</h2>
<p>Suppose that the init-method was part of the service-interface <code>PropFetcher</code> that was introduced above. </p><pre class="fragment">class PropFetcher  {

  public:

  virtual QString value() const = 0;

  virtual void init() = 0;

  virtual ~PropFetcher() = default;
};
</pre><p> We would like to specify the use of the member-function <code>PropFetcher::init()</code> for all services that implement this interface. <br  />
Well, this is how it's done: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;PropFetcher&gt; : default_service_traits&lt;RropFetcher&gt; {
     using initializer_type = service_initializer&lt;&amp;PropFetcher::init&gt;;
  };
}
</pre><p> Of course, in order to take advantage of this, we must advertise our <code>RestPropFetcher</code> under the interface <code>PropFetcher</code>. <br  />
Now, if you advertise a service under more than one interface, an ambiguity could arise, in case more than one interface declares its own service_initializer. In that case, compilation will fail with a corresponding diganostic. <br  />
In order to fix this error, you should specify an initializer_type in the service_traits of the service's <em>implementation-type</em>.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Resolving ambiguities</h1>
<p>Sometimes, multiple instances of a service with the same service-type have been registered. <br  />
 (In our previous examples, this was the case with two instances of the <code>PropFetcher</code> service-type.) <br  />
 If you want to inject only one of those into a dependent service, how can you do that? <br  />
 Well, using the name of the registered service seems like a good idea. The following code will still provide a <code>QList&lt;PropFetcher*&gt;</code> to the <code>PropFetcherAggregator</code>. However, the List will contain solely the service that was registered under the name "hamburgWeather": <br  />
 </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;("hamburgWeather")), "propFetcherAggregator");
</pre> <h1><a class="anchor" id="autotoc_md35"></a>
Customizing service-instantiation</h1>
<p>So far, we have seen that each call to <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a> mirrors a corresponding constructor-invocation of the service-type.</p>
<p>In order for this to work, several pre-conditions must be true:</p>
<ol type="1">
<li>the constructor of the service must be accessible, i.e. declared <code>public</code>.</li>
<li>The number of mandatory arguments must match the arguments provided via <code>QApplicationContext::registerService()</code>, in excess of the service-name and, optionally, the <code>service_config</code>.</li>
<li>For each <code>Dependency&lt;T&gt;</code> with <code>Kind::MANDATORY</code> or <code>Kind::OPTIONAL</code>, the argument-type must be <code>T*</code>.</li>
<li>For each <code>Dependency&lt;T&gt;</code> with <code>Kind::N</code>, the argument-type must be <code>QList&lt;T*&gt;</code>.</li>
</ol>
<p>If any of these conditions fails, then the invocation of <code>QApplicationContext::registerService()</code> will fail compilation.</p>
<p>Suppose that the declaration of the class <code>PropFetcherAggregator</code> has been changed in the following way: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  static PropFetcherAggregator* create(const std::vector&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);

  private:

  explicit PropFetcherAggregator(const std::vector&lt;PropFetcher*&gt;&amp; fetchers, QObject* parent = nullptr);
};
</pre><p> Two things have been changed:</p>
<ol type="1">
<li>Instead of the constructor, which is now private, there is a public static factory-function "create".</li>
<li>The list of PropFetchers is supplied as a <code>std::vector</code>, not as a <code>QList</code>.</li>
</ol>
<p>Now, service-registration will fail, as <code>PropFetcherAggregator</code>'s constructor cannot be invoked.</p>
<p>Luckily, there are two ways of solving this: you can either specialize the template <a class="el" href="structmcnepp_1_1qtdi_1_1service__factory.html" title="A template that can be specialized to override the standard way of instantiating services....">mcnepp::qtdi::service_factory</a> for your service-type, or you can provide your own factory.</p>
<p>(This twofold-approach follows precedent from the standard-library, where you can either specizalize std::hash, or provide your own 'hasher' to classes such as std::unordered_set.)</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Specializing service_factory</h2>
<p>As with all such specializations, it must reside in the namespace of the primary template, i.e. <code>mcnepp::qtdi</code>.</p>
<p>The specialization must provide a call-operator that takes the arguments provided by QApplicationContext, adapts those arguments to the arguments expected by the service-type, and returns a pointer to the newly created service.<br  />
 Additionally, it should provide a type-declaration <code>service_type</code>:</p>
<p>Here is all that we have to do: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_factory&lt;PropFetcherAggregator&gt; {
    using service_type = PropFetcherAggregator;

    PropFetcherAggregator* operator()(const QList&lt;PropFetcher*&gt; fetchers) const {
      return PropFetcherAggregator::create(std::vector&lt;PropFetcher*&gt;{fetchers.begin(), fetchers.end()});
    }
  };
}
</pre><p> And, voila: We can register our service exactly as we did before!</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Provide a custom factory</h2>
<p>Your custom factory must provide a suitable operator(). Additionally, it should provide a type-declaration <code>service_type</code>:</p>
<pre class="fragment">  struct propfetcher_factory {
    using service_type = PropFetcherAggregator;

    PropFetcherAggregator* operator()(const QList&lt;PropFetcher*&gt; fetchers) const {
      return PropFetcherAggregator::create(std::vector&lt;PropFetcher*&gt;{fetchers.begin(), fetchers.end()});
    }
  };
}
</pre><p> This factory should now be used with every service of type <code>PropFetcherAggregator</code>. To achieve this, you declare a type-alias named <code>factory_type</code> in the <a class="el" href="structmcnepp_1_1qtdi_1_1service__traits.html" title="The traits for services.  Every specialization of this template must provide at least the following d...">mcnepp::qtdi::service_traits</a>: </p><pre class="fragment">namespace mcnepp::qtdi {
  template&lt;&gt; struct service_traits&lt;PropFetcherAggregator&gt; : default_service_traits&lt;PropFetcherAggregator&gt; {
    using factory_type = propfetcher_factory;
  };
}
</pre><h1><a class="anchor" id="autotoc_md38"></a>
Publishing an ApplicationContext more than once</h1>
<p>Sometimes, it may be desirable to inovoke QApplicationContext::publish(bool) more than once. Proceeding with the previous example, there may be several independent modules that each want to supply a service of type <code>PropFetcher</code>. Each of these modules will rightly assume that the dependency of type <code>QNetworkAccessManager</code> will be automatically supplied by the QApplicationContext.</p>
<p>But which module shall then invoke QApplicationContext::publish(bool)? Do we need to coordinate this with additional code? That could be a bit unwieldly. Luckily, this is not necessary.</p>
<p>Given that each module has access to the (global) QApplicationContext, you can simply do this in some initialization-code in module A: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()), "hamburgWeather", config({{"url", "${weatherUrl}${hamburgStationId}"}})); 
context -&gt; publish();
</pre><p> ...and this in module B: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcher,RestPropFetcher&gt;(inject&lt;QNetworkAccessManager&gt;()), "berlinWeather", config({{"url", "${weatherUrl}${berlinStationId}"}})); 
context -&gt; publish();
</pre><p> At the first <code>publish()</code>, an instance of <code>QNetworkAccessManager</code> will be instantiated. It will be injected into both <code>RestPropFetchers</code>.</p>
<p>This will work <b>regardless of the order in which the modules are initialized</b>!</p>
<p>Now let's get back to our class <code>PropFetcherAggregator</code> from above. We'll assume that a third module C contains this initialization-code: </p><pre class="fragment">context -&gt; registerService(service&lt;PropFetcherAggregator&gt;(injectAll&lt;PropFetcher&gt;()), "propFetcherAggregator");
context -&gt; publish();
</pre><p> Unfortunately, this code will only have the desired effect of injecting all <code>PropFetchers</code> into the <code>PropFetcherAggregator</code> if it is executed after the code in modules A and B. Thus, we have once again introduced a mandatory order of initialization!</p>
<p>But we can do better: First, we need to tweak our class <code>PropFetcherAggregator</code> a little: </p><pre class="fragment">class PropFetcherAggregator : public QObject {
  Q_OBJECT

  public:

  explicit PropFetcherAggregator(const QList&lt;PropFetcher*&gt;&amp; fetchers = {}, QObject* parent = nullptr);

  void addPropFetcher(PropFetcher*);
};
</pre><p> As you can see, we've added a default-value for the constructor-argument, thus made the class default-constructible. We've also added a member-function <code>addPropFetcher(PropFetcher*)</code>, which we'll put to use in the revised initialization-code in module C: </p><pre class="fragment">auto aggregatorRegistration = context -&gt; registerService&lt;PropFetcherAggregator&gt;("propFetcherAggregator"); // 1

aggregatorRegistration-&gt;autowire(&amp;PropFetcherAggregator::addPropFetcher); // 2

context -&gt; publish();
</pre><ol type="1">
<li>No need to specify Dependency anymore. Therefore, we can use the simplified overload of QApplicationContext::registerService().</li>
<li>Will cause all PropFetchers to be injected into PropFetcherAggregator.</li>
</ol>
<p>And that's all that is needed to get rid of any mandatory order of initialization of the modules A, B and C.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Publish-mode ('allowPartial')</h1>
<p>The function QApplicationContext::publish(bool) has a boolean argument <code>allowPartial</code> with a default-value of <code>false</code>. The following table shows how this argument affects the outcome of the function:</p>
<h2><a class="anchor" id="autotoc_md40"></a>
allowPartial = false:</h2>
<ul>
<li>Transactional behaviour: Only if it can be validated that all service-dependencies can be resolved will publication begin.</li>
<li>Will either publish all services or no service at all.</li>
<li>All errors that occur while publishing a service will be logged with the level QtMsgType::QtCriticalMessage.</li>
</ul>
<h2><a class="anchor" id="autotoc_md41"></a>
allowPartial = true:</h2>
<ul>
<li>Iterative behaviour: Will publish those services whose dependencies can be resolved.</li>
<li>If publication of one service is not possible reasons that may be fixed, the function will continue to publish other services. Such reasons include:<ul>
<li>unresolved dependencies (as those may be registered later).</li>
<li>unresolved config-values (as those may be configured later).</li>
</ul>
</li>
<li>Such "fixable errors" that occur while publishing a service will be logged with the level QtMsgType::QtWarningMessage.</li>
<li>If publication of one service fails for a reason that is not fixable, the function will will immediately return without attempts to publish other services. Such reasons include:<ul>
<li>ambiguous dependencies (as those cannot not be removed from the ApplicationContext).</li>
<li>non-existing names of Q_PROPERTYs.</li>
<li>syntactically erronous config-keys (such as <code>"$interval}"</code>).</li>
</ul>
</li>
<li>Such "fatal errors" that occur while publishing a service will be logged with the level QtMsgType::QtCriticalMessage.</li>
</ul>
<h1><a class="anchor" id="autotoc_md42"></a>
The global ApplicationContext</h1>
<p>In many applications, you will instantiate exactly one QApplicationContext. In that case, the static function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#abc1d419de6d4d3af4c38a8c5791edc4d" title="Obtains the global instance.  QApplicationContext&#39;s constructor will atomically install this as the g...">mcnepp::qtdi::QApplicationContext::instance()</a> is a convenient means of providing access to that single instance. <br  />
When you create a QApplicationContext, the constructor will set a global variable to the new QApplicationContext, unless it has already been set. Consequently, the first QApplicationContext that you create in your application will become the global instance. <br  />
(Please not that QCoreApplication::instance() exhibits the same behaviour.)</p>
<h1><a class="anchor" id="autotoc_md43"></a>
The implicitly registered Services</h1>
<p>There are two Services that will be implicitly available in all instances of <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext.">mcnepp::qtdi::StandardApplicationContext</a>:</p>
<ul>
<li>The ApplicationContext itself, registered under the name "context".</li>
<li>The QCoreApplication::instance(), registered under the name "application".</li>
</ul>
<p>Both Services will have <code>ServiceScope::EXTERNAL</code>.</p>
<p>Of course, the QCoreApplication::instance() can only be registered if it has been created before the StandardApplicationContext.</p>
<p>If that is not the case, a hook will be installed that will register the QCoreApplication::instance() with the <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#abc1d419de6d4d3af4c38a8c5791edc4d" title="Obtains the global instance.  QApplicationContext&#39;s constructor will atomically install this as the g...">mcnepp::qtdi::QApplicationContext::instance()</a> later.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Multi-threading</h1>
<p>Since the class <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a> is derived from QObject, each ApplicationContext has a <em>thread-affinity</em> to the thread that created it.</p>
<p>As a consequence, there are some restrictions regarding the threads from which some of the ApplicationContext's functions may be invoked.</p>
<p>The main thing to keep in mind is this: <b>An ApplicationContext may only be modified and published in the ApplicationContext's thread.</b></p>
<p>However, any thread may safely obtain a <a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html" title="A type-safe wrapper for a detail::ServiceRegistration.">mcnepp::qtdi::ServiceRegistration</a> or a <a class="el" href="classmcnepp_1_1qtdi_1_1_proxy_registration.html" title="A Registration that manages several ServiceRegistrations of the same type. You can do almost everythi...">mcnepp::qtdi::ProxyRegistration</a> and subscribe to its publication-signal. The signal will be delivered using the target-thread's event-queue.</p>
<p>The following table sums this up:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Function   </th><th class="markdownTableHeadNone">Allowed threads   </th><th class="markdownTableHeadNone">Remarks    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#aafdabdace508bc72e8145ae328d46a11" title="Obtains a ServiceRegistration for a service-type and name.  This function will look up Services by th...">mcnepp::qtdi::QApplicationContext::getRegistration(const QString&amp;) const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#afce592b35526eeb43682e5acab37a63b" title="Obtains a ProxyRegistration for a service-type.  In contrast to the ServiceRegistration that is retur...">mcnepp::qtdi::QApplicationContext::getRegistration() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ada1a1701309d3cd8439845eaa472b60c" title="Obtains a List of all Services that have been registered.  The ServiceRegistrations have a type-argum...">mcnepp::qtdi::QApplicationContext::getRegistrations() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ab9bee920351076344b92a8143b05da81" title="How many services have been published? This property will initially yield false, until publish(bool) ...">mcnepp::qtdi::QApplicationContext::published() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5514133528db14cb3308410984b2b2c1" title="How many services have been registered and not yet published? This property will initially yield 0....">mcnepp::qtdi::QApplicationContext::pendingPublication() const </a>  </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#abc1d419de6d4d3af4c38a8c5791edc4d" title="Obtains the global instance.  QApplicationContext&#39;s constructor will atomically install this as the g...">mcnepp::qtdi::QApplicationContext::instance()</a>   </td><td class="markdownTableBodyNone">any   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a5e297b11ba712085577543de42f07c91" title="Registers a service with this ApplicationContext.  Thread-safety: This function may only be called fr...">mcnepp::qtdi::QApplicationContext::registerService()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid ServiceRegistration.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a8bf49def9048cc92c5aa5d1a9437682f" title="Registers an object with this ApplicationContext. The object will immediately be published....">mcnepp::qtdi::QApplicationContext::registerObject()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid ServiceRegistration.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_service_registration.html#af740c20f57c2c6a24ec31a5691fc5c40" title="Registers an alias for a Service.  If this function is successful, the Service can be referenced by t...">mcnepp::qtdi::ServiceRegistration::registerAlias(const QString&amp;)</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return <code>false</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_registration.html#afacf8c2137a7b568249532a14f53a33f" title="Connects a service with another service from the same QApplicationContext. Whenever a service of the ...">mcnepp::qtdi::Registration::autowire()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid Subscription.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="qapplicationcontext_8h.html#a0f11a14df333d20850559efeee464e15" title="Binds a property of one ServiceRegistration to a property from another Registration....">mcnepp::qtdi::bind()</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">Invocation from another thread will log a diagnostic and return an invalid Subscription.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#ad87cbddf0501c5ea8cb1ebe11176e689" title="Publishes this ApplicationContext. This method may be invoked multiple times. Each time it is invoked...">mcnepp::qtdi::QApplicationContext::publish(bool)</a>   </td><td class="markdownTableBodyNone">only the ApplicationContext's   </td><td class="markdownTableBodyNone">All published services will live in the ApplicationContext's thread.   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md45"></a>
Extending QApplicationContext</h1>
<p>It is not possible to extend the class <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext.">mcnepp::qtdi::StandardApplicationContext</a>, as it is <code>final</code>.</p>
<p>However, it is possible to extend the interface <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a> in your own code. If you do that, you may want to use an instance of <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html" title="A ready-to use implementation of the QApplicationContext.">mcnepp::qtdi::StandardApplicationContext</a> as a <em>delegate</em> inside your derived class. <br  />
Here are some rules that you should follow:</p>
<ul>
<li>You can implement the <b>public</b> pure virtual functions simply by invoking them on the <em>delegate</em>.</li>
<li>The <b>protected</b> pure virtual functions can be implemented by using the corresponding static <code>delegate...()</code> functions from QApplicationContext. Pass in your <em>delegate</em> as the first argument, as shown below.</li>
<li>Be aware that the first StandardApplicationContext that you create as a <em>delegate</em> will automatically become the global instance. This is probably not what you want. Therefore, consider to unset the delegate explicitly, as shown in the code below!</li>
<li>Be aware that the <em>delegate</em> will be injected into all services as a parent automatically (unless they have an explicit parent). Also, the <em>init-methods</em> will receive the <em>delegate</em> as an argument, as will the QApplicationContextPostProcessor::process() method.<br  />
 In order to inject your own implementation instead, use the constructor that accepts a <a class="el" href="classmcnepp_1_1qtdi_1_1_standard_application_context.html#a9f1f630cb0d84ce148f8351e9167122b" title="Determines that a StandardApplicationContext is used as a delegate by another ApplicationContext.">mcnepp::qtdi::StandardApplicationContext::delegate_tag</a> as an additional argument. This is also shown below!</li>
<li>Do not forget to connect your instance to the signals emitted by the delegate. You may use the static function <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html#a8d786fec477e3eaf0959a7ae6ff7188c" title="Connects the signals of a source-context with the corresponding signals of a target-context....">mcnepp::qtdi::QApplicationContext::delegateConnectSignals()</a>, as shown below.</li>
</ul>
<p>Here is an example of a custom implementation of <a class="el" href="classmcnepp_1_1qtdi_1_1_q_application_context.html" title="A DI-Container for Qt-based applications.">mcnepp::qtdi::QApplicationContext</a>: </p><pre class="fragment">Q_DECLARE_LOGGING_CATEGORY(extendedLoggingCategory)

class ExtendedApplicationContext : public mcnepp::qtdi::QApplicationContext {
  Q_OBJECT

  public:

    explicit ExtendedApplicationContext(QObject *parent) :
            mcnepp::qtdi::QApplicationContext{parent},
            m_delegate{new mcnepp::qtdi::StandardApplicationContext{extendedLoggingCategory(), this, mcnepp::qtdi::StandardApplicationContext::delegate_tag}}
    {
        unsetInstance(m_delegate); // Remove the delegate as global instance, should it have been set.
        if(setInstance(this)) { // Attempt to set this as global instance.
            qCInfo(extendedLoggingCategory()).noquote().nospace() &lt;&lt; "Installed " &lt;&lt; this &lt;&lt; " as global instance";
        } 
// Propagate signals from delegate to this:
        delegateConnectSignals(m_delegate, this);
    }


    ~ExtendedApplicationContext() {
        unsetInstance(this);
    }

    bool publish(bool allowPartial) override {
    // Implement a public pure virtual method by invoking on delegate:
        return m_delegate-&gt;publish(allowPartial);
    }

 // More public methods...

  protected:

    mcnepp::qtdi::service_registration_handle_t registerService(const QString &amp;name, const service_descriptor &amp;descriptor, const service_config&amp; config, ServiceScope scope, QObject* baseObject) override {
    // Implement a protected pure virtual method by leveraging the corresponding static helper:
        return delegateRegisterService(m_delegate, name, descriptor, config, scope, baseObject);
    }

 // More protected methods...

  private:
    mcnepp::qtdi::QApplicationContext* const m_m_delegate;
};
</pre> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
